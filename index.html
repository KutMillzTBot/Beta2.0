<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kut Milz TB</title>
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Lightweight Charts -->
  <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap');

    /* ABSOLUTE RULE: DO NOT TOUCH OR CHANGE ANY BACKGROUND CODE */
    body {
      font-family: 'Inter', sans-serif;
      font-weight: 600;
      background: radial-gradient(1200px 700px at 15% 10%, rgba(124,58,237,0.12), rgba(255,255,255,0) 60%),
                  radial-gradient(900px 600px at 85% 20%, rgba(244,114,182,0.10), rgba(255,255,255,0) 55%),
                  linear-gradient(180deg, #fbfbff 0%, #f2efff 55%, #f7fbff 100%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 20px 10px;
    }

    /* ===== Light Pearl UI overrides (keep logic unchanged) ===== */
    .card { backdrop-filter: blur(14px); -webkit-backdrop-filter: blur(14px); }

    /* Make inputs readable on light theme even if Tailwind classes are dark */
    .card input, .card select, .card textarea {
      background: rgba(255,255,255,0.86) !important;
      color: #0f172a !important;
      border-color: rgba(124,58,237,0.22) !important;
    }
    .card input::placeholder { color: rgba(15,23,42,0.45) !important; }
    .card label { color: rgba(17, 24, 39, 0.92) !important; font-weight: 700 !important; }
/* Status pill contrast on light */
    .status-pill { border: 1px solid rgba(124,58,237,0.14); }

    /* Brand title */
    .brand-title{
      font-weight: 900;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      background: linear-gradient(90deg, #f6d365 0%, #fda085 35%, #f6d365 70%, #ffd700 100%);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 0 10px 30px rgba(124,58,237,0.18);
    }

    /* =========================
       LOVE / PREMIUM THEME (LOOK ONLY)
       - No JS edits
       - No ID changes
       - No element removal
    ========================= */
    :root{
      --bg-card: rgba(255, 255, 255, 0.78);
      --bg-card-2: rgba(250, 250, 255, 0.62);
      --border-soft: rgba(124, 58, 237, 0.14);   /* violet */
      --border-strong: rgba(124, 58, 237, 0.22);
      --text: #0f172a;
      --muted: rgba(15, 23, 42, 0.68);

      --rose: rgba(244, 114, 182, 0.95);
      --violet: rgba(124, 58, 237, 0.95);
      --teal: rgba(45, 212, 191, 0.95);

      --shadow: 0 18px 60px rgba(17, 24, 39, 0.16);
      --shadow-soft: 0 10px 30px rgba(17, 24, 39, 0.12);
      --glow-rose: 0 0 0 1px rgba(244,114,182,0.18), 0 0 26px rgba(244,114,182,0.10);
      --glow-violet: 0 0 0 1px rgba(124,58,237,0.18), 0 0 28px rgba(124,58,237,0.12);
      --glow-teal: 0 0 0 1px rgba(45,212,191,0.14), 0 0 24px rgba(45,212,191,0.10);

      --radius: 16px;
    }

    /* Smooth, premium default */
    * { -webkit-tap-highlight-color: transparent; }
    html { scroll-behavior: smooth; }

    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: rgba(30, 41, 59, 0.65); }
    ::-webkit-scrollbar-thumb { background: rgba(148, 163, 184, 0.35); border-radius: 999px; }
    ::-webkit-scrollbar-thumb:hover { background: rgba(148, 163, 184, 0.55); }

    .container-wrapper { width: 100%; max-width: 1200px; }

    /* LOVE cards (glass + premium) */
    .card {
      background: linear-gradient(180deg, var(--bg-card), var(--bg-card-2));
      border: 1px solid var(--border-soft);
      padding: 20px;
      border-radius: var(--radius);
      box-shadow: var(--shadow-soft);
      margin-bottom: 20px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      position: relative;
      overflow: hidden;
      transition: transform 200ms ease, box-shadow 200ms ease, border-color 200ms ease;
    }
    .card::before{
      content:"";
      position:absolute;
      inset:-2px;
      background:
        radial-gradient(700px 220px at 10% 0%, rgba(244,114,182,0.08), transparent 55%),
        radial-gradient(700px 220px at 90% 10%, rgba(167,139,250,0.08), transparent 55%),
        radial-gradient(500px 200px at 50% 110%, rgba(45,212,191,0.05), transparent 60%);
      pointer-events:none;
      opacity: 1;
    }
    .card:hover{
      transform: translateY(-2px);
      border-color: var(--border-strong);
      box-shadow: var(--shadow);
    }

    /* Title glow (keeps text exactly Kut Milz TB) */
    h1{
      letter-spacing: 0.3px;
      text-shadow: 0 0 22px rgba(244,114,182,0.18), 0 0 22px rgba(167,139,250,0.14);
    }

    /* Pills + statuses (must keep "pill" / "status-pill" names for JS) */
    .pill {
      padding: 6px 12px;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 700;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid rgba(148,163,184,0.18);
      box-shadow: 0 8px 20px rgba(0,0,0,0.18);
    }

    .status-pill {
      display: flex;
      align-items: center;
      padding: 6px 12px;
      border-radius: 10px;
      font-size: 0.875rem;
      font-weight: 700;
      border: 1px solid rgba(148,163,184,0.18);
      box-shadow: 0 8px 22px rgba(0,0,0,0.22);
      letter-spacing: 0.2px;
    }

    /* Make ALL buttons feel app-like (without changing behavior) */
    button{
      transition: transform 140ms ease, filter 140ms ease, box-shadow 140ms ease, background-color 140ms ease;
      will-change: transform;
    }
    button:hover{ filter: brightness(1.06); }
    button:active{ transform: translateY(1px) scale(0.99); }
    button:focus-visible{
      outline: none;
      box-shadow: 0 0 0 3px rgba(244,114,182,0.22), 0 0 0 6px rgba(167,139,250,0.14);
    }

    /* Premium inputs/selects everywhere (no structure change) */
    input, select{
      border-radius: 12px !important;
    }
    input:focus, select:focus{
      outline: none !important;
      box-shadow: 0 0 0 3px rgba(244,114,182,0.16), 0 0 0 6px rgba(167,139,250,0.10) !important;
    }

    /* Upgrade the log panels without changing IDs */
    #tx-log, #system-log{
      border-radius: 14px !important;
      border: 1px solid rgba(148,163,184,0.18) !important;
      background: linear-gradient(180deg, rgba(2,6,23,0.40), rgba(2,6,23,0.20)) !important;
      box-shadow: inset 0 0 0 1px rgba(148,163,184,0.06);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    /* Make the alert look premium */
    #cluster-alert{
      box-shadow: var(--glow-violet);
    }

    /* Chart container polish */
    #chart-container {
      width: 100%;
      height: 320px;
      background: linear-gradient(180deg, rgba(11,18,32,0.95), rgba(2,6,23,0.55));
      border: 1px solid rgba(148,163,184,0.20);
      border-radius: var(--radius);
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(148,163,184,0.06), 0 18px 50px rgba(0,0,0,0.28);
    }
    @media (min-width: 1024px) {
      #chart-container { height: 360px; }
    }

    /* Subtle LOVE glow hints on key sections by heading color */
    .text-sky-400 { text-shadow: 0 0 18px rgba(45,212,191,0.10); }
    .text-pink-400, .text-red-300 { text-shadow: 0 0 18px rgba(244,114,182,0.10); }
    .text-emerald-400, .text-emerald-300 { text-shadow: 0 0 18px rgba(16,185,129,0.10); }

    /* Improve small helper text readability */
    .text-slate-400, .text-slate-500{
      color: rgba(226,232,240,0.62) !important;
    }

    /* Make toggle track feel softer (visual only) */
    .peer:checked + div{
      box-shadow: var(--glow-rose);
    }
  
/* =========================================================
   LIGHT PRO THEME (Reference layout colors)
   - White cards, soft gray page, strong blue primary button
   - Clear readable typography
   ========================================================= */
html, body{
  background: #f2f5f9 !important;
  color: #111827 !important;
  font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji" !important;
}

/* main container wrapper stays transparent; cards are white */
.container-wrapper{ background: transparent !important; }

/* Card look (clean like your reference screenshot) */
.card{
  background: #ffffff !important;
  border: 1px solid #e5e7eb !important;
  box-shadow: 0 10px 28px rgba(17,24,39,0.08) !important;
  border-radius: 14px !important;
  color: #111827 !important;
}
.card::before{ display:none !important; } /* remove dark glow overlays */

/* Page title */
h1, #app-title{
  color:#111827 !important;
  text-shadow:none !important;
  font-weight:800 !important;
  letter-spacing:0.2px !important;
}

/* Section titles: dark + subtle divider */
.card > h2{
  color:#111827 !important;
  font-weight:800 !important;
  letter-spacing:0.2px !important;
  padding-bottom: 10px !important;
  border-bottom: 1px solid #e5e7eb !important;
  margin-bottom: 14px !important;
}

/* Labels / secondary text */
.text-slate-300,.text-slate-400,.text-slate-500,
.text-gray-400,.text-gray-500{
  color: #374151 !important;
  font-weight: 600 !important;
}

/* Inputs */
input, select, textarea{
  background:#ffffff !important;
  border:1px solid #d1d5db !important;
  color:#111827 !important;
  border-radius: 12px !important;
  outline: none !important;
}
input:focus, select:focus, textarea:focus{
  border-color:rgba(124,58,237,0.55) !important;
  box-shadow: 0 0 0 4px rgba(124,58,237,0.18) !important;
}

/* Primary button (Start Bot look) */
button, .btn{
  border-radius: 14px !important;
}
#start-btn, #startBotBtn, #start-bot-btn{
  background:#3b82f6 !important;
  color:#ffffff !important;
  font-weight:800 !important;
  padding: 14px 16px !important;
  box-shadow: 0 14px 26px rgba(59,130,246,0.22) !important;
}
#start-btn:hover, #startBotBtn:hover, #start-bot-btn:hover{
  filter: brightness(0.98);
}

/* Status pills like reference */
.status-pill{
  border-radius: 12px !important;
  border: 1px solid rgba(17,24,39,0.08) !important;
  box-shadow: 0 8px 18px rgba(17,24,39,0.10) !important;
  font-weight:800 !important;
}
.bg-red-800, .bg-red-700, .bg-red-600, .bg-red-500{
  background:#ef4444 !important;
  color:#ffffff !important;
}
.bg-emerald-600, .bg-green-600, .bg-emerald-500, .bg-green-500{
  background:#22c55e !important;
  color:#ffffff !important;
}
.bg-slate-700, .bg-slate-600, .bg-slate-800{
  background:#111827 !important;
  color:#ffffff !important;
}

/* Logs: light background like reference */
#tx-log, #system-log{
  background:#f9fafb !important;
  border:1px solid #e5e7eb !important;
  color:#111827 !important;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.7);
  border-radius: 12px !important;
}

/* Make log highlight tags readable */
#system-log .warn, #tx-log .warn { color:#f59e0b !important; font-weight:800; }
#system-log .error, #tx-log .error { color:#ef4444 !important; font-weight:800; }
#system-log .success, #tx-log .success { color:#22c55e !important; font-weight:800; }
#system-log .info, #tx-log .info { color:#111827 !important; font-weight:800; }

/* Session limits card inside: keep clean */
#sess-status{ color:#6b7280 !important; }


/* Primary Start/Stop button like reference */
#toggle-bot-btn{
  background:#3b82f6 !important;
  color:#ffffff !important;
  font-weight:800 !important;
  padding: 14px 16px !important;
  border-radius: 14px !important;
  box-shadow: 0 14px 26px rgba(59,130,246,0.22) !important;
}
#toggle-bot-btn.stop, #toggle-bot-btn[data-state="stop"]{
  background:#ef4444 !important;
  box-shadow: 0 14px 26px rgba(239,68,68,0.18) !important;
}


    /* Mobile/desktop compatibility helpers */
    html { -webkit-text-size-adjust: 100%; }
    body { -webkit-font-smoothing: antialiased; }
    button, input, select, textarea { -webkit-appearance: none; appearance: none; }


.separate-card{
  margin-top:18px;
}
</style>


<style>
/* Visual theme imported (safe) */

    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap');

    /* ABSOLUTE RULE: DO NOT TOUCH OR CHANGE ANY BACKGROUND CODE */
    body {
      font-family: 'Inter', sans-serif;
      font-weight: 600;
      background: radial-gradient(1200px 700px at 15% 10%, rgba(124,58,237,0.12), rgba(255,255,255,0) 60%),
                  radial-gradient(900px 600px at 85% 20%, rgba(244,114,182,0.10), rgba(255,255,255,0) 55%),
                  linear-gradient(180deg, #fbfbff 0%, #f2efff 55%, #f7fbff 100%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 20px 10px;
    }

    /* ===== Light Pearl UI oveides (keep logic unchanged) ===== */
    .card { backdrop-filter: blur(14px); -webkit-backdrop-filter: blur(14px); }

    /* Make inputs readable on light theme even if Tailwind classes are dark */
    .card input, .card select, .card textarea {
      background: rgba(255,255,255,0.86) !important;
      color: #0f172a !important;
      border-color: rgba(124,58,237,0.22) !important;
    }
    .card input::placeholder { color: rgba(15,23,42,0.45) !important; }
    .card label { color: rgba(17, 24, 39, 0.92) !important; font-weight: 700 !important; }
/* Status pill contrast on light */
    .status-pill { border: 1px solid rgba(124,58,237,0.14); }

    /* Brand title */
    .brand-title{
      font-weight: 900;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      background: linear-gradient(90deg, #f6d365 0%, #fda085 35%, #f6d365 70%, #ffd700 100%);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 0 10px 30px rgba(124,58,237,0.18);
    }

    /* =========================
       LOVE / PREMIUM THEME (LOOK ONLY)
       - No JS edits
       - No ID changes
       - No element removal
    ========================= */
    :root{
      --bg-card: rgba(255, 255, 255, 0.78);
      --bg-card-2: rgba(250, 250, 255, 0.62);
      --border-soft: rgba(124, 58, 237, 0.14);   /* violet */
      --border-strong: rgba(124, 58, 237, 0.22);
      --text: #0f172a;
      --muted: rgba(15, 23, 42, 0.68);

      --rose: rgba(244, 114, 182, 0.95);
      --violet: rgba(124, 58, 237, 0.95);
      --teal: rgba(45, 212, 191, 0.95);

      --shadow: 0 18px 60px rgba(17, 24, 39, 0.16);
      --shadow-soft: 0 10px 30px rgba(17, 24, 39, 0.12);
      --glow-rose: 0 0 0 1px rgba(244,114,182,0.18), 0 0 26px rgba(244,114,182,0.10);
      --glow-violet: 0 0 0 1px rgba(124,58,237,0.18), 0 0 28px rgba(124,58,237,0.12);
      --glow-teal: 0 0 0 1px rgba(45,212,191,0.14), 0 0 24px rgba(45,212,191,0.10);

      --radius: 16px;
    }

    /* Smooth, premium default */
    * { -webkit-tap-highlight-color: transparent; }
    html { scroll-behavior: smooth; }

    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: rgba(30, 41, 59, 0.65); }
    ::-webkit-scrollbar-thumb { background: rgba(148, 163, 184, 0.35); border-radius: 999px; }
    ::-webkit-scrollbar-thumb:hover { background: rgba(148, 163, 184, 0.55); }

    .container-wrapper { width: 100%; max-width: 1200px; }

    /* LOVE cards (glass + premium) */
    .card {
      background: linear-gradient(180deg, var(--bg-card), var(--bg-card-2));
      border: 1px solid var(--border-soft);
      padding: 20px;
      border-radius: var(--radius);
      box-shadow: var(--shadow-soft);
      margin-bottom: 20px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      position: relative;
      overflow: hidden;
      transition: transform 200ms ease, box-shadow 200ms ease, border-color 200ms ease;
    }
    .card::before{
      content:"";
      position:absolute;
      inset:-2px;
      background:
        radial-gradient(700px 220px at 10% 0%, rgba(244,114,182,0.08), transparent 55%),
        radial-gradient(700px 220px at 90% 10%, rgba(167,139,250,0.08), transparent 55%),
        radial-gradient(500px 200px at 50% 110%, rgba(45,212,191,0.05), transparent 60%);
      pointer-events:none;
      opacity: 1;
    }
    .card:hover{
      transform: translateY(-2px);
      border-color: var(--border-strong);
      box-shadow: var(--shadow);
    }

    /* Title glow (keeps text exactly Kut Milz TB) */
    h1{
      letter-spacing: 0.3px;
      text-shadow: 0 0 22px rgba(244,114,182,0.18), 0 0 22px rgba(167,139,250,0.14);
    }

    /* Pills + statuses (must keep "pill" / "status-pill" names for JS) */
    .pill {
      padding: 6px 12px;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 700;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid rgba(148,163,184,0.18);
      box-shadow: 0 8px 20px rgba(0,0,0,0.18);
    }

    .status-pill {
      display: flex;
      align-items: center;
      padding: 6px 12px;
      border-radius: 10px;
      font-size: 0.875rem;
      font-weight: 700;
      border: 1px solid rgba(148,163,184,0.18);
      box-shadow: 0 8px 22px rgba(0,0,0,0.22);
      letter-spacing: 0.2px;
    }

    /* Make ALL buttons feel app-like (without changing behavior) */
    button{
      transition: transform 140ms ease, filter 140ms ease, box-shadow 140ms ease, background-color 140ms ease;
      will-change: transform;
    }
    button:hover{ filter: brightness(1.06); }
    button:active{ transform: translateY(1px) scale(0.99); }
    button:focus-visible{
      outline: none;
      box-shadow: 0 0 0 3px rgba(244,114,182,0.22), 0 0 0 6px rgba(167,139,250,0.14);
    }

    /* Premium inputs/selects everywhere (no structure change) */
    input, select{
      border-radius: 12px !important;
    }
    input:focus, select:focus{
      outline: none !important;
      box-shadow: 0 0 0 3px rgba(244,114,182,0.16), 0 0 0 6px rgba(167,139,250,0.10) !important;
    }

    /* Upgrade the log panels without changing IDs */
    #tx-log, #system-log{
      border-radius: 14px !important;
      border: 1px solid rgba(148,163,184,0.18) !important;
      background: linear-gradient(180deg, rgba(2,6,23,0.40), rgba(2,6,23,0.20)) !important;
      box-shadow: inset 0 0 0 1px rgba(148,163,184,0.06);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    /* Make the alert look premium */
    #cluster-alert{
      box-shadow: var(--glow-violet);
    }

    /* Chart container polish */
    #chart-container {
      width: 100%;
      height: 320px;
      background: linear-gradient(180deg, rgba(11,18,32,0.95), rgba(2,6,23,0.55));
      border: 1px solid rgba(148,163,184,0.20);
      border-radius: var(--radius);
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(148,163,184,0.06), 0 18px 50px rgba(0,0,0,0.28);
    }
    @media (min-width: 1024px) {
      #chart-container { height: 360px; }
    }

    /* Subtle LOVE glow hints on key sections by heading color */
    .text-sky-400 { text-shadow: 0 0 18px rgba(45,212,191,0.10); }
    .text-pink-400, .text-red-300 { text-shadow: 0 0 18px rgba(244,114,182,0.10); }
    .text-emerald-400, .text-emerald-300 { text-shadow: 0 0 18px rgba(16,185,129,0.10); }

    /* Improve small helper text readability */
    .text-slate-400, .text-slate-500{
      color: rgba(226,232,240,0.62) !important;
    }

    /* Make toggle track feel softer (visual only) */
    .peer:checked + div{
      box-shadow: var(--glow-rose);
    }
  
/* =========================================================
   LIGHT PRO THEME (Reference layout colors)
   - White cards, soft gray page, strong blue primary button
   - Clear readable typography
   ========================================================= */
html, body{
  background: #f2f5f9 !important;
  color: #111827 !important;
  font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji" !important;
}

/* main container wrapper stays transparent; cards are white */
.container-wrapper{ background: transparent !important; }

/* Card look (clean like your reference screenshot) */
.card{
  background: #ffffff !important;
  border: 1px solid #e5e7eb !important;
  box-shadow: 0 10px 28px rgba(17,24,39,0.08) !important;
  border-radius: 14px !important;
  color: #111827 !important;
}
.card::before{ display:none !important; } /* remove dark glow overlays */

/* Page title */
h1, #app-title{
  color:#111827 !important;
  text-shadow:none !important;
  font-weight:800 !important;
  letter-spacing:0.2px !important;
}

/* Section titles: dark + subtle divider */
.card > h2{
  color:#111827 !important;
  font-weight:800 !important;
  letter-spacing:0.2px !important;
  padding-bottom: 10px !important;
  border-bottom: 1px solid #e5e7eb !important;
  margin-bottom: 14px !important;
}

/* Labels / secondary text */
.text-slate-300,.text-slate-400,.text-slate-500,
.text-gray-400,.text-gray-500{
  color: #374151 !important;
  font-weight: 600 !important;
}

/* Inputs */
input, select, textarea{
  background:#ffffff !important;
  border:1px solid #d1d5db !important;
  color:#111827 !important;
  border-radius: 12px !important;
  outline: none !important;
}
input:focus, select:focus, textarea:focus{
  border-color:rgba(124,58,237,0.55) !important;
  box-shadow: 0 0 0 4px rgba(124,58,237,0.18) !important;
}

/* Primary button (Start Bot look) */
button, .btn{
  border-radius: 14px !important;
}
#start-btn, #startBotBtn, #start-bot-btn{
  background:#3b82f6 !important;
  color:#ffffff !important;
  font-weight:800 !important;
  padding: 14px 16px !important;
  box-shadow: 0 14px 26px rgba(59,130,246,0.22) !important;
}
#start-btn:hover, #startBotBtn:hover, #start-bot-btn:hover{
  filter: brightness(0.98);
}

/* Status pills like reference */
.status-pill{
  border-radius: 12px !important;
  border: 1px solid rgba(17,24,39,0.08) !important;
  box-shadow: 0 8px 18px rgba(17,24,39,0.10) !important;
  font-weight:800 !important;
}
.bg-red-800, .bg-red-700, .bg-red-600, .bg-red-500{
  background:#ef4444 !important;
  color:#ffffff !important;
}
.bg-emerald-600, .bg-green-600, .bg-emerald-500, .bg-green-500{
  background:#22c55e !important;
  color:#ffffff !important;
}
.bg-slate-700, .bg-slate-600, .bg-slate-800{
  background:#111827 !important;
  color:#ffffff !important;
}

/* Logs: light background like reference */
#tx-log, #system-log{
  background:#f9fafb !important;
  border:1px solid #e5e7eb !important;
  color:#111827 !important;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.7);
  border-radius: 12px !important;
}

/* Make log highlight tags readable */
#system-log .warn, #tx-log .warn { color:#f59e0b !important; font-weight:800; }
#system-log .eor, #tx-log .eor { color:#ef4444 !important; font-weight:800; }
#system-log .success, #tx-log .success { color:#22c55e !important; font-weight:800; }
#system-log .info, #tx-log .info { color:#111827 !important; font-weight:800; }

/* Session limits card inside: keep clean */
#sess-status{ color:#6b7280 !important; }


/* Primary Start/Stop button like reference */
#toggle-bot-btn{
  background:#3b82f6 !important;
  color:#ffffff !important;
  font-weight:800 !important;
  padding: 14px 16px !important;
  border-radius: 14px !important;
  box-shadow: 0 14px 26px rgba(59,130,246,0.22) !important;
}
#toggle-bot-btn.stop, #toggle-bot-btn[data-state="stop"]{
  background:#ef4444 !important;
  box-shadow: 0 14px 26px rgba(239,68,68,0.18) !important;
}


    /* Mobile/desktop compatibility helpers */
    html { -webkit-text-size-adjust: 100%; }
    body { -webkit-font-smoothing: antialiased; }
    button, input, select, textarea { -webkit-appearance: none; appearance: none; }



/* === MOBILE / IOS / ANDROID COMPATIBILITY PATCH === */
@media (max-width: 1024px){
  .grid, .lg\:grid-cols-3, .lg\:col-span-2, .lg\:col-span-1{
    display:block !important;
    width:100% !important;
  }
  .card{
    margin-bottom:14px !important;
  }
}
@media (max-width: 768px){
  body{
    zoom:0.92;
  }
  button{
    min-height:44px;
  }
}


.-stage{padding:8px;border-radius:8px;border:1px solid #cbd5f5;text-align:center;opacity:.4;transition:.3s}
.-stage.active{opacity:1;background:#1e3a8a;color:#fff}
.tx-card{border:1px solid #e5e7eb;border-radius:12px;padding:10px}
.tx-win{background:#dcfce7}
.tx-loss{background:#fee2e2}


/* === PATCH: Responsive dashboard + trade cards (additive only) === */
.trade-cards { display: grid; grid-template-columns: repeat(auto-fill,minmax(260px,1fr)); gap: 14px; }
.trade-card { background: linear-gradient(180deg, var(--bg-card), var(--bg-card-2)); border:1px solid var(--border-soft); border-radius:14px; padding:12px; box-shadow: var(--shadow-soft); }
.trade-card .row{ display:flex; justify-content:space-between; font-size:0.8rem; margin-top:4px; }
.trade-card .badge{ padding:4px 8px; border-radius:999px; font-weight:800; font-size:0.7rem; }
.badge.pending{ background:rgba(148,163,184,.25); }
.badge.won{ background:rgba(45,212,191,.35); }
.badge.lost{ background:rgba(244,114,182,.35); }
@media (max-width:768px){
  .container-wrapper{ padding:0 6px; }
  .trade-cards{ grid-template-columns:1fr; }
}


html, body {
  background-color: #141414 !important;
}
body > * {
  background-color: transparent !important;
}
/* common full-screen wrappers */
#app, #root, .app, .root, .container, .wrapper {
  background-color: transparent !important;
}


/* Extra info panels below  */
.ai-extra-panels{
  background:#1a1a1a;
  color:#e6e6e6;
  border:1px solid #2a2a2a;
  padding:8px;
  margin-top:8px;
  font-size:12px;
}
.ai-extra-panels h4{
  margin:4px 0;
  font-size:13px;
  color:#9fd3ff;
}


/* Mobile-first adjustments */
@media (max-width: 768px) {
  body {
    font-size: 12px;
  }
  .ai-extra-panels {
    font-size: 11px;
    padding: 6px;
  }
  button, input, select {
    font-size: 14px;
    min-height: 38px;
  }
  canvas {
    max-width: 100% !important;
    height: auto !important;
  }
}

/* Tablet */
@media (min-width: 769px) and (max-width: 1024px) {
  body {
    font-size: 13px;
  }
}

/* Touch optimization */
button, input, select {
  touch-action: manipulation;
}


/* Force white background for specific panels by title text */
.panel, .module, .section {
  position: relative;
}

/* Match panels containing specific labels */
.panel:has(h3:contains("Scalp Timing Assist")),
.panel:has(h3:contains("Accumulator")) {
  background: #ffffff !important;
  color: #000000 !important;
}

/* Fallback for non-structured layouts */
[data-title*="Scalp Timing Assist"],
[data-title*="Accumulator"] {
  background: #ffffff !important;
  color: #000000 !important;
}

/* Watermark */
body::before {
  content: "KUT MILZ TB";
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) rotate(-15deg);
  font-size: 64px;
  font-weight: 700;
  color: rgba(230,195,106,0.08);
  letter-spacing: 6px;
  pointer-events: none;
  z-index: 0;
}

/* Keep UI above watermark */
body > * {
  position: relative;
  z-index: 1;
}


/* Repeating background watermark */
body::before {
  content: "KUT MILZ TB   KUT MILZ TB   KUT MILZ TB   KUT MILZ TB";
  position: fixed;
  inset: 0;
  background-image:
    repeating-linear-gradient(
      -30deg,
      rgba(230,195,106,0.07) 0px,
      rgba(230,195,106,0.07) 60px,
      transparent 60px,
      transparent 120px
    );
  font-size: 48px;
  font-weight: 700;
  color: rgba(230,195,106,0.12);
  letter-spacing: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  z-index: 0;
}

/* Keep all UI above pattern */
body > * {
  position: relative;
  z-index: 1;
}


.separate-card{
  margin-top:18px;
}
</style>


<style>
/* === BOT NAME LIGHT GOLD FIX === */
.bot-name,
.app-title,
.header-title,
h1, h2{
  color: #f5d77a !important; /* light gold */
  text-shadow: 0 0 6px rgba(245,215,122,0.35);
}

.separate-card{
  margin-top:18px;
}
</style>



<style>
/* === SECTION HEADER LIGHT GOLD THEME === */
.section-title,
.card-title,
h3,
h4{
  color: #f5d77a !important;
  font-weight: 600;
  text-shadow: 0 0 4px rgba(245,215,122,0.25);
}

/* Target specific named sections */
:where(
  .bot-controls,
  .trade-settings,
  .account-summary,
  .trading-parameters,
  .transaction-log,
  .system-log,
  .scalp-timing,
  .accumulator
) h2,
:where(
  .bot-controls,
  .trade-settings,
  .account-summary,
  .trading-parameters,
  .transaction-log,
  .system-log,
  .scalp-timing,
  .accumulator
) h3{
  color: #f5d77a !important;
}

/* Keep Accumulator (Scalp) card dark-blue, text gold */
.accumulator,
.accumulator.card{
  background: linear-gradient(135deg, #0b1a33, #132a52) !important;
}
.accumulator h2,
.accumulator h3,
.accumulator p{
  color: #f5d77a !important;
}

/* Sub-labels slightly dimmed gold */
label,
.small,
.help-text{
  color: rgba(245,215,122,0.75) !important;
}

.separate-card{
  margin-top:18px;
}
</style>



<style>
/* === GLOBAL DARK BLUE + GOLD CARD THEME (SAFE VISUAL ONLY) === */

/* Main cards / sections */
.card,
.section,
.bot-controls,
.trade-settings,
.account-summary,
.trading-parameters,
.transaction-log,
.system-log,
.scalp-timing,
.accumulator {
  background: linear-gradient(135deg, #0b1a33, #132a52) !important;
  border: 1px solid rgba(245,215,122,0.15) !important;
}

/* Section titles */
.card h2,
.card h3,
.section h2,
.section h3 {
  color: #f5d77a !important;
  font-weight: 600;
  text-shadow: 0 0 4px rgba(245,215,122,0.25);
}

/* Labels and helper text */
label,
.help-text,
.small,
.card p {
  color: rgba(245,215,122,0.8) !important;
}

/* Inputs remain readable */
input,
select,
textarea {
  background: rgba(255,255,255,0.08) !important;
  color: #ffffff !important;
  border: 1px solid rgba(245,215,122,0.25) !important;
}

/* Buttons untouched except text color */
button {
  color: #ffffff;
}

.separate-card{
  margin-top:18px;
}
</style>



<style id="contrast-fix">
.section-title,
.card h2,
.card h3,
.panel-title {
  color: #f5d77a !important;
  font-weight: 600;
}

.label,
.field-label,
.status-label,
.card label,
.card .row-label {
  color: #ffffff !important;
  opacity: 1 !important;
}

.help-text,
.description,
.subtext,
.card small {
  color: #f2f2ff !important;
  opacity: 1 !important;
}

.card hr,
.section-divider {
  border-color: rgba(245,215,122,0.45) !important;
}

.separate-card{
  margin-top:18px;
}
</style>



<style>
/* Dark blue + gold/white card style */
.dark-gold-card {
  background: linear-gradient(180deg, #0b1f3a, #0e2a4d);
  border-radius: 14px;
  border: 1px solid rgba(255,215,130,0.35);
  box-shadow: 0 10px 30px rgba(0,0,0,.35);
}
.dark-gold-card h3,
.dark-gold-card h4 {
  color: #f5d27a;
}
.dark-gold-card p,
.dark-gold-card span,
.dark-gold-card label {
  color: #ffffff;
}

/*  section */
#session-limited-section {
  margin-top: 20px;
}

.separate-card{
  margin-top:18px;
}
</style>


</head>

<body>
<div class="container-wrapper" id="app-root">
  <h1 class="text-3xl text-center mb-6 brand-title">KUT MILZ TB</h1>

  <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

    <!-- Column 1 -->
    <div class="lg:col-span-1">

      <!-- Bot Controls -->
      <div class="card">
        <h2 class="text-xl font-semibold mb-4 text-sky-400">Bot Controls</h2>

        <div class="mt-2 border-t border-slate-700 pt-4 space-y-3">
          <h3 class="text-lg font-medium text-slate-300">Live Status</h3>

          <div class="flex justify-between items-center">
            <span class="text-sm">Connection:</span>
            <span id="connection-status" class="status-pill bg-red-800 text-white">DISCONNECTED</span>
          </div>

          <div class="flex justify-between items-center">
            <span class="text-sm">Account Type:</span>
            <span id="account-type-status" class="status-pill bg-slate-600 text-slate-300">UNKNOWN</span>
          </div>

          <div class="flex justify-between items-center">
            <span class="text-sm">Trade Active:</span>
            <span id="trade-active-status" class="status-pill bg-slate-600 text-slate-300">Idle</span>
          </div>

          <div class="flex justify-between items-center">
            <span class="text-sm">Current Mode:</span>
            <span id="mode-status" class="status-pill bg-indigo-800 text-white">SCALP</span>
          </div>

          <div class="flex justify-between items-center">
            <span class="text-sm">H4 Trend:</span>
            <span id="h4-trend-display" class="status-pill bg-slate-600 text-slate-300">OFF</span>
          </div>

          <div class="flex justify-between items-center">
            <span class="text-sm">Reason Blocked:</span>
            <span id="block-reason-display" class="status-pill bg-slate-600 text-slate-300">None</span>
          </div>

          <!-- AI Guard (Safety Filter) -->
          <div class="mt-3 p-3 rounded-lg border border-slate-700 bg-slate-900/30">
            <div class="flex items-center justify-between gap-3">
              <div class="flex items-center gap-2">
                <span class="text-sm font-semibold text-slate-200">AI Guard</span>
                <span id="ai-guard-status" class="text-xs text-slate-300">AI: ON | Regime: NORMAL | Confidence: 100% | Last: None</span>
              </div>
              <label class="relative inline-flex items-center cursor-pointer">
                <input type="checkbox" id="ai-guard-toggle" class="sr-only peer" checked>
                <div class="w-11 h-6 bg-slate-500 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-sky-300 rounded-full peer
                  peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px]
                  after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-sky-600"></div>
              </label>
            </div>
            <div class="mt-2 text-[11px] text-slate-400">
              Safety-only filter: can <b>block/pause</b> trades on spikes, chop, drawdown, or overtrading. Does <b>not</b> change signals.
            </div>
          </div>

          <div id="account-warning" class="hidden mt-3 p-3 rounded-lg border border-red-500/40 bg-red-500/10 text-sm text-red-200">
            ⚠️ Symbol not available on this account. Use a Deriv <b>Derived/Synthetic (STD)</b> account for Volatility indices and Vol 1s.
          </div>
        </div>
      </div>

      <!-- Account Summary -->
      <div class="card">
        <h2 class="text-xl font-semibold mb-4 text-sky-400">Account Summary</h2>
        <div class="space-y-3">
          <div class="flex justify-between items-center border-b border-slate-700 pb-2">
            <span class="text-sm">Current Balance:</span>
            <span id="current-balance-display" class="text-lg font-bold text-yellow-400">...</span>
          </div>

          <div class="flex justify-between items-center">
            <span class="text-sm">Session Profit (USD):</span>
            <span id="current-profit-display" class="text-lg font-bold text-slate-300">0.00</span>
          </div>

          <!-- -->
          <div class="flex justify-between items-center">
            <span class="text-sm">Session Loss (USD):</span>
            <span id="current-loss-display" class="text-lg font-bold text-red-300">0.00</span>
          </div>
          <!-- Session Limits (TP/SL + Win/Loss/Trade caps) -->
          <div class="mt-4 p-3 rounded-lg border" style="border-color: var(--border-soft); background: rgba(255,255,255,0.55);">
            <div class="flex items-center justify-between gap-2">
              <div>
                <div class="text-sm font-semibold" style="color: rgba(15,23,42,0.92);">Session Limits</div>
                <div id="sess-limit-status" class="text-xs" style="color: rgba(15,23,42,0.60);">Limits OFF</div>
              </div>

              <div class="flex items-center gap-2">
                <label class="inline-flex items-center gap-2 text-xs" style="color: rgba(15,23,42,0.78);">
                  <input id="sess-limit-enabled" type="checkbox" class="h-4 w-4">
                  Enable
                </label>
                <button id="sess-limit-reset" class="text-xs py-2 px-3 rounded bg-slate-600 hover:bg-slate-500 text-white">
                  Reset
                </button>
              </div>
            </div>

            <div class="grid grid-cols-3 gap-2 mt-3">
              <div>
                <label for="sess-maxProfit" class="block text-xs mb-1">Max Profit (TP)</label>
                <input id="sess-maxProfit" type="number" step="0.01" placeholder="e.g. 2.00" class="w-full p-2 rounded border">
              </div>
              <div>
                <label for="sess-maxLoss" class="block text-xs mb-1">Max Loss (SL)</label>
                <input id="sess-maxLoss" type="number" step="0.01" placeholder="e.g. 2.00" class="w-full p-2 rounded border">
              </div>
              <div>
                <label for="sess-maxTrades" class="block text-xs mb-1">Max Trades</label>
                <input id="sess-maxTrades" type="number" step="1" placeholder="e.g. 25" class="w-full p-2 rounded border">
              </div>
              <div>
                <label for="sess-maxWins" class="block text-xs mb-1">Max Wins</label>
                <input id="sess-maxWins" type="number" step="1" placeholder="e.g. 10" class="w-full p-2 rounded border">
              </div>
              <div>
                <label for="sess-maxLosses" class="block text-xs mb-1">Max Losses</label>
                <input id="sess-maxLosses" type="number" step="1" placeholder="e.g. 5" class="w-full p-2 rounded border">
              </div>
              <div class="flex items-end">
                <div id="sess-counts" class="text-xs w-full p-2 rounded border"
                     style="border-color: rgba(124,58,237,0.18); background: rgba(255,255,255,0.70); color: rgba(15,23,42,0.78);">
                  Trades: 0 | Wins: 0 | Losses: 0
                </div>
              </div>
            </div>

            <div class="mt-2 text-[11px]" style="color: rgba(15,23,42,0.55);">
              Stops the bot automatically when TP/SL or win/loss/trade limits are reached.
            </div>
          </div>


          <div class="flex justify-between items-center">
            <span class="text-sm">Contract Sellable:</span>
            <span id="sellable-display" class="status-pill bg-red-500 text-white">NO</span>
          </div>
        </div>
      </div>

      <!-- -->
      <div class="card">
        <h2 class="text-xl font-semibold mb-4 text-emerald-300">
<section id="session-limited-section" class="dark-gold-card">
  <h3></h3>
  <p></p>
</section>

<h2 class="section-title gold"><span class="section-title gold">Transaction Log</span></h2></h2>
        <div class="p-3 bg-slate-900/40 border border-slate-700 rounded-lg text-xs whitespace-pre-wrap min-h-[120px] max-h-[220px] overflow-auto"
             id="tx-log"></div>
        <div class="mt-3 flex gap-2">
          <button id="clear-txlog-btn" class="text-xs py-2 px-3 rounded bg-slate-600 hover:bg-slate-500 text-white">Clear Log</button>
          <button id="export-txlog-btn" class="text-xs py-2 px-3 rounded bg-slate-600 hover:bg-slate-500 text-white">Copy Log</button>
        </div>
        <div class="mt-2 text-[11px] text-slate-400">
          Format: <span class="text-slate-300">CLOSED | SYMBOL | CALL/PUT | +/-value</span>
        </div>
      </div>

      <!-- System Log -->
      <div class="card">
        <h2 class="text-xl font-semibold mb-4 text-amber-300">System Log</h2>
        <div class="p-3 bg-slate-900/40 border border-slate-700 rounded-lg text-xs whitespace-pre-wrap min-h-[120px] max-h-[220px] overflow-auto"
             id="system-log"></div>
        <div class="mt-3 flex gap-2">
          <button id="clear-log-btn" class="text-xs py-2 px-3 rounded bg-slate-600 hover:bg-slate-500 text-white">Clear Log</button>
          <button id="export-log-btn" class="text-xs py-2 px-3 rounded bg-slate-600 hover:bg-slate-500 text-white">Copy Log</button>
        </div>
      </div>

    </div>

    <!-- Column 2 -->
    <div class="lg:col-span-2">

      <!-- Clustering Detected Alert -->
      <div id="cluster-alert" class="card hidden border-yellow-500/40">
        <div class="flex items-start gap-3">
          <div class="text-yellow-400 text-xl">⚠️</div>
          <div>
            <div class="text-lg font-semibold text-yellow-300">Clustering Detected</div>
            <div id="cluster-text" class="text-sm text-slate-200 mt-1">
              3+ clusters in last 5 ticks suggests possible reversal/indecision.
            </div>
          </div>
        </div>
      </div>

      <!-- Confidence Meter -->
      <div class="card">
        <div class="flex items-center justify-between mb-3">
          <h2 class="text-xl font-semibold text-emerald-400">Confidence Meter</h2>
          <span id="signal-pill" class="pill bg-slate-700 text-slate-200">WAIT</span>
        </div>

        <div class="w-full bg-slate-700 rounded-full h-4 overflow-hidden">
          <div id="confidence-bar" class="h-4 bg-emerald-500" style="width:0%"></div>
        </div>
        <div class="flex justify-between mt-2 text-xs text-slate-300">
          <div id="confidence-text">0%</div>
          <div id="confidence-notes" class="text-slate-400">Waiting ticks…</div>
        </div>

        <div class="mt-3 text-xs text-slate-400">
          If <b>Auto Trading</b> is OFF, you can use this bar + signal to decide manual entries. Not financial advice.
        </div>
      </div>

      <!-- Trade Settings -->
      <div class="card">
        <h2 class="text-xl font-semibold mb-4 text-sky-400">Trade Settings</h2>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">

          <div>
            <label class="block text-sm font-medium mb-1">Select Market</label>
            <select id="symbolSelect"
              class="w-full p-2 rounded bg-slate-700 border border-slate-600 text-slate-50 focus:ring-sky-500 focus:border-sky-500">
<option value="R_10">Volatility 10 Index (R_10)</option>
              <option value="R_25">Volatility 25 Index (R_25)</option>
              <option value="R_50">Volatility 50 Index (R_50)</option>
              <option value="R_75">Volatility 75 Index (R_75)</option>
              <option selected>Volatility 100 Index (R_100)</option>
              <option value="1HZ10V">Volatility 10 (1s) (1HZ10V)</option>
              <option value="1HZ25V">Volatility 25 (1s) (1HZ25V)</option>
              <option value="1HZ50V">Volatility 50 (1s) (1HZ50V)</option>
              <option value="1HZ75V">Volatility 75 (1s) (1HZ75V)</option>
              <option value="1HZ100V">Volatility 100 (1s) (1HZ100V)</option>
    <option value="BOOM300">Boom 300 Index</option>
    <option value="BOOM500">Boom 500 Index</option>
    <option value="BOOM600">Boom 600 Index</option>
    <option value="BOOM900">Boom 900 Index</option>
    <option value="BOOM1000">Boom 1000 Index</option>
    <option value="CRASH300">Crash 300 Index</option>
    <option value="CRASH500">Crash 500 Index</option>
    <option value="CRASH600">Crash 600 Index</option>
    <option value="CRASH900">Crash 900 Index</option>
    <option value="CRASH1000">Crash 1000 Index</option>
</select>
            <p class="text-xs text-slate-400 mt-2">
              Current symbol: <span id="currentSymbolLabel" class="text-sky-300 font-semibold">R_100</span>
            </p>
          </div>

          <div>
            <label class="block text-sm font-medium mb-1">Custom Symbol (optional)</label>
            <div class="flex gap-2">
              <input id="customSymbol" placeholder="Example: R_100 or 1HZ100V"
                class="flex-1 p-2 rounded bg-slate-700 border border-slate-600 text-slate-50 focus:ring-sky-500 focus:border-sky-500"/>
              <button id="applySymbolBtn"
                class="py-2 px-3 rounded bg-sky-700 hover:bg-sky-800 text-white text-sm font-semibold">
                Apply
              </button>
            </div>
            <p class="text-xs text-slate-400 mt-2">
              If symbol fails to stream, you may be on an account that doesn’t allow it. Use a Derived/STD account for Volatility indices.
            </p>
          </div>

          <div class="md:col-span-2 grid grid-cols-2 gap-3">
            <button id="placeTradeBtn" class="py-3 rounded-xl font-bold bg-emerald-700 hover:bg-emerald-800 text-white">
              Place Trade (<span id="placeStakeLabel">$1.00</span>)
            </button>
            <button id="clearHistoryBtn" class="py-3 rounded-xl font-bold bg-red-700 hover:bg-red-800 text-white">
              Clear History
            </button>
            <button id="bulk3Btn" class="py-3 rounded-xl font-bold bg-fuchsia-700 hover:bg-fuchsia-800 text-white">
              Bulk 3 (<span id="bulk3Label">$3.00</span>)
            </button>
            <button id="bulk5Btn" class="py-3 rounded-xl font-bold bg-sky-700 hover:bg-sky-800 text-white">
              Bulk 5 (<span id="bulk5Label">$5.00</span>)
            </button>
          </div>

          <div class="md:col-span-2 flex items-center justify-between p-3 bg-slate-700/50 rounded-lg mt-1">
            <div class="flex items-center gap-3">
              <div class="text-purple-300 text-xl">⚡</div>
              <div>
                <div class="font-semibold text-slate-200">Auto Trading</div>
                <div class="text-xs text-slate-400">Enable to start automated trading based on current settings</div>
              </div>
            </div>
            <label class="relative inline-flex items-center cursor-pointer">
              <input type="checkbox" id="autoTradingToggle" class="sr-only peer" checked>
              <div class="w-11 h-6 bg-slate-500 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-sky-300 rounded-full peer
                peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px]
                after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-sky-600"></div>
            </label>
          </div>

        </div>
      </div>

      <!-- Trading Parameters -->
      <div class="card">
        <h2 class="text-xl font-semibold mb-4 text-sky-400">Trading Parameters</h2>

        <div class="grid grid-cols-2 gap-4">
          <div>
            <label for="stakeAmount" class="block text-sm font-medium mb-1">Stake Amount (USD)</label>
            <input type="number" id="stakeAmount" step="0.01"
              class="w-full p-2 rounded bg-slate-700 border border-slate-600 text-slate-50 focus:ring-sky-500 focus:border-sky-500">
          </div>

          <div class="col-span-2 p-3 rounded-lg border border-slate-700 bg-slate-900/30">
            <div class="flex items-center justify-between gap-3">
              <div>
                <div class="text-sm font-medium text-slate-300">Risk % Stake (Auto Lot Size)</div>
                <div id="riskStakePreview" class="text-[11px] text-slate-400">Auto stake: OFF</div>
              </div>
              <label class="relative inline-flex items-center cursor-pointer">
                <input type="checkbox" id="riskSizingEnabled" class="sr-only peer" disabled>
                <div class="w-11 h-6 bg-slate-500 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-sky-300 rounded-full peer
                  peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px]
                  after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-sky-600"></div>
              </label>
            </div>

            <div class="grid grid-cols-1 sm:grid-cols-3 gap-3 mt-3">
              <div>
                <label for="riskSizingPct" class="block text-xs mb-1">Risk per trade (%)</label>
                <input id="riskSizingPct" type="number" step="0.1" placeholder="1"
                  class="w-full p-2 rounded bg-slate-700 border border-slate-600 text-slate-50 focus:ring-sky-500 focus:border-sky-500" disabled>
              </div>
              <div>
                <label for="riskSizingMin" class="block text-xs mb-1">Min Stake (USD)</label>
                <input id="riskSizingMin" type="number" step="0.01" placeholder="0.35"
                  class="w-full p-2 rounded bg-slate-700 border border-slate-600 text-slate-50 focus:ring-sky-500 focus:border-sky-500" disabled>
              </div>
              <div>
                <label for="riskSizingMax" class="block text-xs mb-1">Max Stake (USD) (0 = no cap)</label>
                <input id="riskSizingMax" type="number" step="0.01" placeholder="0"
                  class="w-full p-2 rounded bg-slate-700 border border-slate-600 text-slate-50 focus:ring-sky-500 focus:border-sky-500" disabled>
              </div>
            </div>

            <div class="mt-2 text-[11px] text-slate-400">
              When ON: <b>stake = balance × (risk% / 100)</b>, then clamped by Min/Max. (This is your auto lot size.)
            </div>
          </div>

          <div>
            <label for="maxTradesPerSignal" class="block text-sm font-medium mb-1">Max Trades/Signal</label>
            <input type="number" id="maxTradesPerSignal" step="1"
              class="w-full p-2 rounded bg-slate-700 border border-slate-600 text-slate-50 focus:ring-sky-500 focus:border-sky-500">
          </div>

          <div>
            <label for="duration" class="block text-sm font-medium mb-1">Duration</label>
            <input type="number" id="duration" step="1"
              class="w-full p-2 rounded bg-slate-700 border border-slate-600 text-slate-50 focus:ring-sky-500 focus:border-sky-500">
          </div>

          <div>
            <label for="durationUnit" class="block text-sm font-medium mb-1">Duration Unit</label>
            <select id="durationUnit"
              class="w-full p-2 rounded bg-slate-700 border border-slate-600 text-slate-50 focus:ring-sky-500 focus:border-sky-500">
              <option value="t">Ticks</option>
              <option value="s">Seconds</option>
              <option value="m">Minutes</option>
              <option value="h">Hours</option>
            </select>
          </div>

          <div>
            <label for="tpUSD" class="block text-sm font-medium mb-1">Take Profit (USD)</label>
            <input type="number" id="tpUSD" step="0.01"
              class="w-full p-2 rounded bg-slate-700 border border-slate-600 text-slate-50 focus:ring-sky-500 focus:border-sky-500">
          </div>

          <div>
            <label for="slUSD" class="block text-sm font-medium mb-1">Stop Loss (USD)</label>
            <input type="number" id="slUSD" step="0.01"
              class="w-full p-2 rounded bg-slate-700 border border-slate-600 text-slate-50 focus:ring-sky-500 focus:border-sky-500">
          </div>

          <div class="col-span-2">
            <label for="cooldownDuration" class="block text-sm font-medium mb-1">Cooldown Duration (s)</label>
            <input type="number" id="cooldownDuration" step="1"
              class="w-full p-2 rounded bg-slate-700 border border-slate-600 text-slate-50 focus:ring-sky-500 focus:border-sky-500">
          </div>
        </div>
      </div>
          
      <!-- Burst Protection + Soft Score (advanced, optional) -->
      <div class="mt-4 p-4 rounded-lg border border-slate-700 bg-slate-900/30">
        <div class="text-sm font-extrabold text-slate-200 mb-2">Scalp Timing Assist (Advanced)</div>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
          <!-- Burst Protection -->
          <div class="p-3 bg-slate-700/50 rounded-lg">
            <div class="flex items-center justify-between">
              <div class="flex flex-col sm:flex-row sm:items-center">
                <span class="text-sm font-medium text-slate-300 mr-3">Burst Protection:</span>
                <span id="burst-protect-indicator" class="pill bg-red-600 text-white">OFF</span>
              </div>
              <label class="relative inline-flex items-center cursor-pointer">
                <input type="checkbox" id="burst-protect-toggle" class="sr-only peer" disabled>
                <div class="w-11 h-6 bg-slate-500 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-pink-300 rounded-full peer
                  peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px]
                  after:bg-white after:border-gray-300 after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-pink-600"></div>
              </label>
            </div>

            <div class="grid grid-cols-2 gap-2 mt-3">
              <div>
                <label class="text-xs text-slate-400">Lookback ticks</label>
                <input id="burst-protect-lookback" type="number" min="10" max="200" step="1" value="40"
                  class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
              </div>
              <div>
                <label class="text-xs text-slate-400">Spike mult</label>
                <input id="burst-protect-mult" type="number" min="1" max="10" step="0.1" value="3.5"
                  class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
              </div>
              <div>
                <label class="text-xs text-slate-400">Min cooldown (s)</label>
                <input id="burst-protect-mincd" type="number" min="5" max="600" step="1" value="45"
                  class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
              </div>
              <div>
                <label class="text-xs text-slate-400">Max cooldown (s)</label>
                <input id="burst-protect-maxcd" type="number" min="5" max="600" step="1" value="120"
                  class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
              </div>
            </div>

            <div class="text-center text-xs text-slate-500 mt-2" id="burst-protect-status">Burst Protection is OFF.</div>
          </div>

          <!-- Soft Score -->
          <div class="p-3 bg-slate-700/50 rounded-lg">
            <div class="flex items-center justify-between">
              <div class="flex flex-col sm:flex-row sm:items-center">
                <span class="text-sm font-medium text-slate-300 mr-3">Soft Score:</span>
                <span id="soft-score-indicator" class="pill bg-red-600 text-white">OFF</span>
              </div>
              <label class="relative inline-flex items-center cursor-pointer">
                <input type="checkbox" id="soft-score-toggle" class="sr-only peer" disabled>
                <div class="w-11 h-6 bg-slate-500 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-pink-300 rounded-full peer
                  peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px]
                  after:bg-white after:border-gray-300 after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-pink-600"></div>
              </label>
            </div>

            <div class="grid grid-cols-3 gap-2 mt-3">
              <div>
                <label class="text-xs text-slate-400">Block below</label>
                <input id="soft-score-block" type="number" min="0" max="100" step="1" value="45"
                  class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
              </div>
              <div>
                <label class="text-xs text-slate-400">Boost below</label>
                <input id="soft-score-boost" type="number" min="0" max="100" step="1" value="60"
                  class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
              </div>
              <div>
                <label class="text-xs text-slate-400">Boost cooldown (s)</label>
                <input id="soft-score-boostcd" type="number" min="0" max="600" step="1" value="20"
                  class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
              </div>
            </div>

            <div class="text-center text-xs text-slate-500 mt-2" id="soft-score-status">Soft Score is OFF.</div>
          </div>
        </div>

        <div class="text-[11px] text-slate-400 mt-3">
          Tip: Turn these ON for Vol 1s to improve timing without over-blocking. They only stand down during bursts / low-quality conditions.
        </div>
      </div>

<!-- Accumulator (True ACCU) -->
          <div class="mt-4 p-4 rounded-lg border border-slate-700 bg-slate-900/30">
            <div class="flex items-center justify-between gap-3">
              <div>
                <div class="text-sm font-extrabold text-slate-200">Accumulator (Scrape)</div>
                <div class="text-xs text-slate-400">True <b>ACCU</b> contract with <b>Growth %</b> + optional <b>Auto-sell TP</b>.</div>
              </div>
              <label class="relative inline-flex items-center cursor-pointer">
                <input type="checkbox" id="accu-toggle" class="sr-only peer">
                <div class="w-11 h-6 bg-slate-500 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-sky-300 rounded-full peer
                  peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px]
                  after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-sky-600"></div>
              </label>
            </div>

            <div id="accu-settings" class="mt-3 grid grid-cols-2 gap-3">
              <div>
                <label class="block text-sm font-medium mb-1">Growth rate</label>
                <div id="accu-growth-bar" class="grid grid-cols-5 gap-2 bg-slate-800/60 p-1 rounded-xl border border-slate-700">
                  <button type="button" class="accu-growth-btn py-2 rounded-lg text-sm font-semibold bg-slate-700 text-slate-200 hover:bg-slate-600" data-accu-growth="0.01">1%</button>
                  <button type="button" class="accu-growth-btn py-2 rounded-lg text-sm font-semibold bg-slate-700 text-slate-200 hover:bg-slate-600" data-accu-growth="0.02">2%</button>
                  <button type="button" class="accu-growth-btn py-2 rounded-lg text-sm font-semibold bg-slate-700 text-slate-200 hover:bg-slate-600" data-accu-growth="0.03">3%</button>
                  <button type="button" class="accu-growth-btn py-2 rounded-lg text-sm font-semibold bg-slate-700 text-slate-200 hover:bg-slate-600" data-accu-growth="0.04">4%</button>
                  <button type="button" class="accu-growth-btn py-2 rounded-lg text-sm font-semibold bg-slate-700 text-slate-200 hover:bg-slate-600" data-accu-growth="0.05">5%</button>
                </div>
                <!-- hidden input used by existing logic -->
                <input type="hidden" id="accu-growth" value="0.01" />
              </div>

              <div>
                <label for="accu-tp" class="block text-sm font-medium mb-1">Auto-sell TP (profit $)</label>
                <input type="number" id="accu-tp" step="0.01" placeholder="e.g. 0.50"
                  class="w-full p-2 rounded bg-slate-700 border border-slate-600 text-slate-50 focus:ring-sky-500 focus:border-sky-500">
              </div>

              <div class="col-span-2 flex items-center justify-between p-3 bg-slate-700/40 rounded-lg">
                <div>
                  <div class="text-sm font-semibold text-slate-200">Accumulator Safe Mode</div>
                  <div class="text-xs text-slate-400">Caps growth to <b>12%</b> and lets AI Guard block spike/chop.</div>
                </div>
                <label class="relative inline-flex items-center cursor-pointer">
                  <input type="checkbox" id="accu-safe" class="sr-only peer" checked>
                  <div class="w-11 h-6 bg-slate-500 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-pink-300 rounded-full peer
                    peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px]
                    after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-pink-600"></div>
                </label>
              </div>

              <div class="col-span-2 text-[11px] text-slate-400">
                When <b>Accumulator</b> is ON, your normal CALL/PUT direction is still calculated, but entries will purchase an ACCU contract instead.
              </div>
            </div>
          </div>


      <!-- Protected Defaults -->
      <div class="card">
        <div class="flex justify-between items-start mb-4 border-b border-slate-700 pb-3">
          <h2 class="text-xl font-semibold text-pink-400">Protected Defaults</h2>
          <button id="unlock-settings-btn"
            class="text-sm text-pink-400 hover:text-pink-300 font-medium py-1 px-3 rounded-full border border-pink-500 transition duration-150">
            Unlock
          </button>
        </div>

        <div class="space-y-4">

          <div class="flex items-center justify-between p-3 bg-slate-700/50 rounded-lg">
            <div class="flex flex-col sm:flex-row sm:items-center">
              <span class="text-sm font-medium text-slate-300 mr-4">Strategy Mode:</span>
              <span id="mode-pill" class="pill bg-indigo-600 text-white">SCALP</span>
            </div>
            <select id="mode-select"
              class="p-1 rounded bg-slate-600 text-xs border border-slate-500 focus:ring-indigo-500"
              disabled>
              <option value="SCALP">SCALP (Fast Tap-Out)</option>
              <option value="MOMENTUM">MOMENTUM (Trend + Breakout)</option>
              <option value="H4">H4 MODE (Strict Trend + Breakout)</option>
            </select>
          </div>

          <div class="flex items-center justify-between p-3 bg-slate-700/50 rounded-lg">
            <div class="flex flex-col sm:flex-row sm:items-center">
              <span class="text-sm font-medium text-slate-300 mr-4">Safe Mode:</span>
              <span id="safe-mode-indicator" class="pill bg-red-600 text-white">OFF</span>
            </div>
            <label class="relative inline-flex items-center cursor-pointer">
              <input type="checkbox" id="safe-mode-toggle" class="sr-only peer" disabled>
              <div class="w-11 h-6 bg-slate-500 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-pink-300 rounded-full peer
                peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px]
                after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-pink-600"></div>
            </label>
          </div>

          <div class="text-center text-xs text-slate-500" id="safe-mode-status">
            Safe Mode is currently DISABLED.
          </div>


          <div class="flex items-center justify-between p-3 bg-slate-700/50 rounded-lg">
            <div class="flex flex-col sm:flex-row sm:items-center">
              <span class="text-sm font-medium text-slate-300 mr-4">Price Action Filter:</span>
              <span id="price-action-indicator" class="pill bg-emerald-600 text-white">ON</span>
            </div>
            <label class="relative inline-flex items-center cursor-pointer">
              <input type="checkbox" id="price-action-toggle" class="sr-only peer" disabled checked>
              <div class="w-11 h-6 bg-slate-500 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-pink-300 rounded-full peer
                peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px]
                after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-pink-600"></div>
            </label>
          </div>

          <div class="text-center text-xs text-slate-500" id="price-action-status">
            Price Action Filter is currently ENABLED.
          </div>

          <!-- Chart Assist -->
          <div class="flex items-center justify-between p-3 bg-slate-700/50 rounded-lg">
            <div class="flex flex-col sm:flex-row sm:items-center">
              <span class="text-sm font-medium text-slate-300 mr-4">Chart Assist (FVG / Pullback / Double):</span>
              <span id="chart-assist-indicator" class="pill bg-red-600 text-white">OFF</span>
            </div>
            <label class="relative inline-flex items-center cursor-pointer">
              <input type="checkbox" id="chart-assist-toggle" class="sr-only peer" disabled>
              <div class="w-11 h-6 bg-slate-500 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-pink-300 rounded-full peer
                peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px]
                after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-pink-600"></div>
            </label>
          </div>

          <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
            <div>
              <label class="text-xs text-slate-400">Assist Mode</label>
              <select id="chart-assist-mode" class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled>
                <option value="BOOST">BOOST cooldown only</option>
                <option value="GATE">GATE entries (optional)</option>
              </select>
            </div>
            <div>
              <label class="text-xs text-slate-400">Min Cooldown (seconds)</label>
              <input id="chart-assist-mincd" type="number" step="0.5" min="0" value="2"
                class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
            </div>
          </div>

          <div class="text-center text-xs text-slate-500" id="chart-assist-status">
            Chart Assist is currently OFF.
          </div>


          <div class="flex items-center justify-between p-3 bg-slate-700/50 rounded-lg">
            <div class="flex flex-col sm:flex-row sm:items-center">
              <span class="text-sm font-medium text-slate-300 mr-4">Auto-resume after cooldown:</span>
              <span id="autoresume-indicator" class="pill bg-emerald-600 text-white">ON</span>
            </div>
            <label class="relative inline-flex items-center cursor-pointer">
              <input type="checkbox" id="autoresume-toggle" class="sr-only peer" disabled checked>
              <div class="w-11 h-6 bg-slate-500 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-pink-300 rounded-full peer
                peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px]
                after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-pink-600"></div>
            </label>
          </div>


          <div class="flex items-center justify-between p-3 bg-slate-700/50 rounded-lg">
            <div class="flex flex-col sm:flex-row sm:items-center">
              <span class="text-sm font-medium text-slate-300 mr-4">Auto-sell (TP close):</span>
              <span id="autosell-indicator" class="pill bg-emerald-600 text-white">ON</span>
            </div>
            <label class="relative inline-flex items-center cursor-pointer">
              <input type="checkbox" id="autosell-toggle" class="sr-only peer" disabled checked>
              <div class="w-11 h-6 bg-slate-500 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-pink-300 rounded-full peer
                peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px]
                after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-pink-600"></div>
            </label>
          </div>

        </div>
          
          <!-- Scalp Indicator Assist (SCALP only) -->
          <div class="flex items-center justify-between p-3 bg-slate-700/50 rounded-lg mt-2">
            <div class="flex flex-col sm:flex-row sm:items-center">
              <span class="text-sm font-medium text-slate-300 mr-4">Scalp Indicator Assist (MA / BB / RSI / MACD):</span>
              <span id="scalp-ind-indicator" class="pill bg-red-600 text-white">OFF</span>
            </div>
            <label class="relative inline-flex items-center cursor-pointer">
              <input type="checkbox" id="scalp-ind-toggle" class="sr-only peer" disabled>
              <div class="w-11 h-6 bg-slate-500 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-pink-300 rounded-full peer
                peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px]
                after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-pink-600"></div>
            </label>
          </div>

          <div class="grid grid-cols-1 sm:grid-cols-4 gap-3 mt-2">
            <div>
              <label class="text-xs text-slate-400">Mode</label>
              <select id="scalp-ind-mode" class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled>
                <option value="BOOST_ONLY">BOOST (cooldown only)</option>
                <option value="GATE">GATE (block conflicts)</option>
              </select>
            </div>
            <div>
              <label class="text-xs text-slate-400">MA period</label>
              <input id="scalp-ind-ma" type="number" min="5" max="300" step="1" value="70"
                class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
            </div>
            <div>
              <label class="text-xs text-slate-400">BB period</label>
              <input id="scalp-ind-bbperiod" type="number" min="5" max="300" step="1" value="50"
                class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
            </div>
            <div>
              <label class="text-xs text-slate-400">BB std</label>
              <input id="scalp-ind-bbstd" type="number" min="0.5" max="5" step="0.1" value="2"
                class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
            </div>
          </div>

          <div class="grid grid-cols-1 sm:grid-cols-4 gap-3 mt-2">
            <div>
              <label class="text-xs text-slate-400">RSI period</label>
              <input id="scalp-ind-rsi" type="number" min="5" max="100" step="1" value="14"
                class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
            </div>
            <div>
              <label class="text-xs text-slate-400">MACD fast</label>
              <input id="scalp-ind-mfast" type="number" min="2" max="50" step="1" value="12"
                class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
            </div>
            <div>
              <label class="text-xs text-slate-400">MACD slow</label>
              <input id="scalp-ind-mslow" type="number" min="5" max="100" step="1" value="26"
                class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
            </div>
            <div>
              <label class="text-xs text-slate-400">MACD signal</label>
              <input id="scalp-ind-msig" type="number" min="2" max="50" step="1" value="9"
                class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
            </div>
          </div>

          <div class="grid grid-cols-1 sm:grid-cols-3 gap-3 mt-2">
            <div>
              <label class="text-xs text-slate-400">Boost min score</label>
              <input id="scalp-ind-boostmin" type="number" min="0" max="100" step="1" value="60"
                class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
            </div>
            <div>
              <label class="text-xs text-slate-400">Gate min score</label>
              <input id="scalp-ind-gatemin" type="number" min="0" max="100" step="1" value="40"
                class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
            </div>
            <div>
              <label class="text-xs text-slate-400">Hard conflict %</label>
              <input id="scalp-ind-hardconf" type="number" min="0" max="100" step="1" value="20"
                class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
            </div>
          </div>

          <div class="text-center text-xs text-slate-500" id="scalp-ind-status">
            Scalp Indicator Assist is DISABLED.
          </div>

          <!-- Smart Take-Out -->
          <div class="flex items-center justify-between p-3 bg-slate-700/50 rounded-lg mt-2">
            <div class="flex flex-col sm:flex-row sm:items-center">
              <span class="text-sm font-medium text-slate-300 mr-4">Smart Take-Out (21 tick):</span>
              <span id="smart-takeout-indicator" class="pill bg-red-600 text-white">OFF</span>
            </div>
            <label class="relative inline-flex items-center cursor-pointer">
              <input type="checkbox" id="smart-takeout-toggle" class="sr-only peer" disabled>
              <div class="w-11 h-6 bg-slate-500 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-pink-300 rounded-full peer
                peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px]
                after:bg-white after:border-gray-300 after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-pink-600"></div>
            </label>
          </div>

          <div class="grid grid-cols-1 sm:grid-cols-4 gap-3 mt-2">
            <div>
              <label class="text-xs text-slate-400">Primary ticks (early)</label>
              <input id="smart-takeout-primary" type="number" min="1" step="1" value="2"
                class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
            </div>
            <div>
              <label class="text-xs text-slate-400">Fallback ticks (near max duration)</label>
              <input id="smart-takeout-fallback" type="number" min="1" step="1" value="1"
                class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
            </div>
            <div>
              <label class="text-xs text-slate-400">Switch after % of max duration</label>
              <input id="smart-takeout-fallbackpct" type="number" min="0" max="100" step="1" value="70"
                class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
            </div>
            <div>
              <label class="text-xs text-slate-400">Stall ticks required</label>
              <input id="smart-takeout-stallticks" type="number" min="1" max="3" step="1" value="1"
                class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
            </div>
          </div>

          <div class="text-center text-xs text-slate-500 mt-2" id="smart-takeout-status">
            Smart Take-Out is OFF.
          </div>



        
          <!-- Tick Ladder (1/2/3) -->
          <div class="flex items-center justify-between p-3 bg-slate-700/50 rounded-lg mt-3">
            <div class="flex flex-col sm:flex-row sm:items-center">
              <span class="text-sm font-medium text-slate-300 mr-4">Tick Ladder (1/2/3):</span>
              <span id="tick-ladder-indicator" class="pill bg-red-600 text-white">OFF</span>
            </div>
            <label class="relative inline-flex items-center cursor-pointer">
              <input type="checkbox" id="tick-ladder-toggle" class="sr-only peer" disabled>
              <div class="w-11 h-6 bg-slate-500 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-pink-300 rounded-full peer
                peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px]
                after:bg-white after:border-gray-300 after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-pink-600"></div>
            </label>
          </div>

          <div class="grid grid-cols-1 sm:grid-cols-5 gap-3 mt-2">
            <div>
              <label class="text-xs text-slate-400">Start ticks</label>
              <input id="tick-ladder-start" type="number" min="1" step="1" value="1"
                class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
            </div>
            <div>
              <label class="text-xs text-slate-400">Mid ticks</label>
              <input id="tick-ladder-mid" type="number" min="1" step="1" value="2"
                class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
            </div>
            <div>
              <label class="text-xs text-slate-400">Max ticks</label>
              <input id="tick-ladder-max" type="number" min="1" step="1" value="3"
                class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
            </div>
            <div>
              <label class="text-xs text-slate-400">Quick window (ticks)</label>
              <input id="tick-ladder-window" type="number" min="1" max="10" step="1" value="3"
                class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
            </div>
            <div>
              <label class="text-xs text-slate-400">Double-touch count</label>
              <input id="tick-ladder-dtouch" type="number" min="1" max="5" step="1" value="2"
                class="w-full mt-1 p-2 bg-slate-800 border border-slate-600 rounded text-slate-100" disabled />
            </div>
          </div>

          <div class="text-center text-xs text-slate-500 mt-2" id="tick-ladder-status">
            Tick Ladder is OFF.
          </div>

<div class="mt-4 pt-3 border-t border-slate-700">
          <p class="text-xs text-center text-slate-500">Made by Kut.Milz</p>
        </div>
      </div>

      <!-- Chart Card -->
      <div class="card">
        <div class="flex items-center justify-between mb-3">
          <h2 class="text-xl font-semibold text-sky-400">Live Chart</h2>
          <span id="chart-status" class="pill bg-slate-700 text-slate-200">WAITING</span>
        </div>
        <div id="chart-container"></div>
        <p class="text-xs text-slate-400 mt-2">
          Live <span class="text-sky-300 font-semibold">1-second candles</span> built from Deriv tick stream (auto-fallback supported).
        </p>
      </div>

      <!-- API Login -->
      <div class="card">
        <div class="flex justify-between items-center mb-4 pb-3 border-b border-slate-700">
          <h2 class="text-xl font-semibold text-sky-400">API Login</h2>
          <span id="login-status-badge" class="pill bg-red-800 text-white animate-pulse">DISCONNECTED</span>
        </div>

        <div class="relative mb-3">
          <label for="api-token" class="block text-sm font-medium mb-1 text-slate-300">Deriv API Token</label>
          <div class="flex items-center rounded-lg bg-slate-700 border border-slate-600 focus-within:ring-2 focus-within:ring-sky-500 transition duration-150">
            <span class="p-3 text-sky-400">
              <svg xmlns="https://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 5.25a3 3 0 0 1 3 3v2.25m-15.75 6a3 3 0 0 1 3-3h2.25m3.75-10.25v12a3 3 0 0 1-3 3h-2.25a3 3 0 0 1-3-3v-2.25m15.75-6a3 3 0 0 1-3 3h-2.25a3 3 0 0 1-3-3v-2.25m3.75 10.25v-12a3 3 0 0 1 3-3h2.25a3 3 0 0 1 3 3v2.25" />
              </svg>
            </span>

            <input type="password" id="api-token" placeholder="Paste your API token here..."
              class="flex-1 p-3 bg-transparent border-none text-slate-50 focus:ring-0 focus:outline-none placeholder-slate-400"
              autocomplete="off">

            <button id="toggle-visibility-btn" class="p-3 text-slate-400 hover:text-sky-300 transition duration-150"
              type="button" title="Show Token">
              <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.8" stroke="currentColor" class="w-5 h-5">
  <path stroke-linecap="round" stroke-linejoin="round" d="M2.036 12.322a1 1 0 0 1 0-.644C3.423 7.51 7.36 4.5 12 4.5c4.638 0 8.577 3.01 9.964 7.178a1 1 0 0 1 0 .644C20.577 16.49 16.64 19.5 12 19.5c-4.638 0-8.577-3.01-9.964-7.178Z" />
  <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" />
</svg>
            </button>
          </div>
        </div>

        <div class="relative mb-3">
          <label for="start-password" class="block text-sm font-medium mb-1 text-slate-300">Start Password</label>
          <input type="password" id="start-password" placeholder="Type password to start bot…"
            class="w-full p-3 rounded-lg bg-slate-700 border border-slate-600 text-slate-50 focus:ring-sky-500 focus:border-sky-500"
            autocomplete="off" />
          <p id="pw-error-message" class="mt-2 text-sm text-red-300 hidden">
            Access Denied: Incorrect password to start bot.
          </p>
        </div>

        <button id="toggle-bot-btn"
          class="w-full py-3 rounded-lg font-bold transition duration-200 bg-emerald-600 hover:bg-emerald-700 text-white shadow-lg">
          START BOT
        </button>

        <p id="token-error-message" class="text-sm text-red-400 mt-3 hidden">API token required to start the bot.</p>

        <p class="text-xs text-slate-500 mt-3">
          <span class="font-semibold text-sky-300">Permissions:</span> Read + Trade
        </p>

        <p id="edit-hint" class="text-xs text-slate-500 mb-4">
          Token stored in browser (localStorage). Never share it.
        </p>

        <div class="p-3 bg-slate-700 rounded-lg border border-slate-600 flex flex-col sm:flex-row justify-between items-start sm:items-center">
          <div class="text-xs space-y-1 sm:space-y-0">
            <p>API URL: <code id="api-url-text" class="text-yellow-400 break-all text-[11px] select-all font-mono">wss://ws.binaryws.com/websockets/v3?app_id=1089</code></p>
          </div>
          <button id="copy-api-url-btn"
            class="mt-2 sm:mt-0 text-xs py-1 px-3 rounded-full bg-slate-600 hover:bg-slate-500 transition duration-150 text-white font-medium"
            type="button">
            Copy URL
          </button>
        </div>
      </div>

      <!-- Insights -->
      <div class="card">
        <h2 class="text-xl font-semibold mb-4 text-emerald-400">Market Insights ✨</h2>

        <div class="flex flex-col sm:flex-row gap-4 mb-4">
          <button id="analyze-market-btn" class="flex-1 py-2 rounded-lg font-bold transition duration-200 bg-emerald-700 hover:bg-emerald-800 text-white shadow-lg">
            Analyze Market Sentiment ✨
          </button>
          <button id="assess-risk-btn" class="flex-1 py-2 rounded-lg font-bold transition duration-200 bg-pink-700 hover:bg-pink-800 text-white shadow-lg">
            Assess Strategy Risk ✨
          </button>
        </div>

        <div id="gemini-loading-indicator" class="hidden text-center text-sm text-yellow-500 py-4">
          Generating insight...
        </div>

        <div id="gemini-output" class="p-3 bg-slate-700 rounded-lg text-sm text-slate-100 min-h-[100px] whitespace-pre-wrap">
          Tap a button above for analysis. (Works even without API key.)
        </div>

        <div class="mt-3 text-xs text-slate-400">
          Note: This is NOT financial advice. Signals can be wrong — always risk-manage.
        </div>
      </div>

    </div>
  </div>
</div>

<script>
/* =========================================================
   SAFE DOM + LOGGING
========================================================= */
function $(id){ return document.getElementById(id); }
const LOG = $("system-log");
const TXLOG = $("tx-log");
function logLine(msg){
  const t = new Date().toLocaleTimeString();
  const line = `[${t}] ${msg}`;
  console.log(line);
  if (LOG){
    LOG.textContent = (LOG.textContent ? (LOG.textContent + "\n") : "") + line;
    LOG.scrollTop = LOG.scrollHeight;
  }
}

// 
// Transaction log lines: CLOSED | SYMBOL | CALL/PUT | +/-value
function txLogLine(msg){
  const t = new Date().toLocaleTimeString();
  const line = `[${t}] ${msg}`;
  console.log("TX:", line);
  if (TXLOG){
    TXLOG.textContent = (TXLOG.textContent ? (TXLOG.textContent + "\n") : "") + line;
    TXLOG.scrollTop = TXLOG.scrollHeight;
  }
}

/* =========================================================
   CONFIG
========================================================= */
const API_URL = 'wss://ws.binaryws.com/websockets/v3?app_id=1089';
const REQUIRED_PASSWORD = "$1977";



/* =========================================================
   MODE DEFAULTS (Momentum best = Minutes)
========================================================= */
const modeDefaults = {
  SCALP:   { stake:1.00, duration:5, durationUnit:'t', tp:0.34, sl:10.00, maxTrades:1, cooldown:30, tickBuf:6,  thr:0.015, trend:false, strict:false },
  MOMENTUM:{ stake:2.00, duration:1, durationUnit:'m', tp:0.60, sl:15.00, maxTrades:1, cooldown:45, tickBuf:10, thr:0.030, trend:true,  strict:false },
  H4:      { stake:2.00, duration:2, durationUnit:'m', tp:0.80, sl:20.00, maxTrades:1, cooldown:60, tickBuf:12, thr:0.040, trend:true,  strict:true  }
};

/* =========================================================
   STATE
========================================================= */
const appState = {
  ws:null,
  token: localStorage.getItem('derivToken') || '',
  isBotRunning:false,
  isAuthenticated:false,
  isEntryInProgress:false,

  symbol: "R_100",

  currentBalance:0,

  // 
// Session tracking
  sessionProfit:0,     // net P/L
  sessionLoss:0,       // absolute loss total
// Session limits (extra safety layer)
  sessionTrades: 0,
  sessionWins: 0,
  sessionLosses: 0,
  sessLimitsEnabled: false,
  sessMaxProfit: null,
  sessMaxLoss: null,
  sessMaxTrades: null,
  sessMaxWins: null,
  sessMaxLosses: null,
  sessStopReason: null,


  tradeCounter:0,
  currentContractId:null,
  is_sellable:0,
  isSelling:false,

  // 
// Track last trade meta so TX log shows CALL/PUT + symbol
  currentDirection:null,       // "CALL" / "PUT"
  currentSymbolAtEntry:null,   // e.g., "R_100"

  mode:'SCALP',
  isSettingsLocked:true,
  isSafeMode:false,
  autoResume:true,
  autoSellEnabled:true,
  autoTradingEnabled:true,

autoTradingEnabled:true,


  // Chart Assist: optional chart-pattern helper (does NOT change core strategy unless user sets mode=GATE)
  chartAssist:{
    enabled:false,
    mode:"BOOST",           // BOOST | GATE
    minCooldownSec:2,       // when boosting, reduce cooldown to at least this
    threshold:70            // 0..100
  },

  // Scalp Indicator Assist: optional indicator confirmation (SCALP only). Does NOT change direction.
  scalpInd:{
    enabled:false,
    mode:"BOOST_ONLY",      // BOOST_ONLY | GATE
    maPeriod:70,
    bbPeriod:50,
    bbStd:2,
    rsiPeriod:14,
    macdFast:12,
    macdSlow:26,
    macdSignal:9,
    boostMinScore:60,       // 0..100
    gateMinScore:40,        // 0..100
    hardConflictScore:20    // 0..100 (conflict % threshold)
  },


  smartTakeout:{
    enabled:false,
    primaryTicks:2,
    fallbackTicks:1,
    fallbackAfterPct:70,
    stallTicksRequired:1
  },

  // Tick Ladder (optional): dynamic 1/2/3 tick take-out based on early momentum (SCALP + tick duration only)
  tickLadder:{
    enabled:false,
    startTicks:1,
    midTicks:2,
    maxTicks:3,
    quickWindowTicks:3,
    doubleTouchCount:2
  },

  // Burst Protection (optional): stand down briefly during tick-volatility bursts (best for Vol 1s)
  burstProtect:{
    enabled:false,
    lookback:40,
    spikeMult:3.5,
    minCooldownS:45,
    maxCooldownS:120,
    refractoryS:6
  },

  // Soft Score (optional): soft filter that boosts cooldown in bad conditions instead of hard-blocking everything
  softScore:{
    enabled:false,
    blockBelow:45,
    boostBelow:60,
    boostCooldownS:20
  },

  burstCooldownUntil:0,
  softScoreCooldownUntil:0,

  stakeAmount:1.00,
  
  // Risk-based stake sizing (auto lot size)
  riskSizing:{ enabled:false, pct:1, minStake:0.35, maxStake:0 },

duration:5,
  durationUnit:'t',
  tpUSD:0.34,
  slUSD:10.00,
  maxTradesPerSignal:1,
  cooldownDuration:30,
  cooldownUntil:0,

  tickBuffer:[],
  tickBufferSize:6,
  momentumThreshold:0.015,
  lastTick:null,

  // last digits for clustering (last 5 ticks)
  lastDigits:[],

  // proposal/buy flow
  pendingProposalId:null,

  // trend
  useTrendFilter:false,
  breakoutStrict:false,
  trend:{
    enabled:false,
    status:"OFF",
    tfSeconds:14400,   // H4 = 4 hours
    emaFast:20,
    emaSlow:50,
    lastUpdated:0,
    refreshMs:60000
  },

  // chart candle aggregator
  chart:{
    lastCandleTime:0,
    lastOHLC:null,
    hasTick:false,

    /* 
 PRICE ACTION: closed 1s candle history (used by filter) */
    closedCandles: []  // {time, open, high, low, close}
  },

  //  Feature guards (added, default ON but safe)
  volGuard:{
    enabled:true,
    lookbackCandles:20,
    deadMinRange:0,      // absolute min range (auto ok)
    deadMaxMult:0.35,    // last range < avg*mult => too quiet
    spikeMaxMult:3.5     // last range > avg*mult => spike
  },
  candleChecks:{
    enabled:true,
    requireStrongClose:true,
    requireWickRejection:true,
    requireBreakRetest:false // optional (strict) - enable in MOMENTUM/H4
  },
  htfConfirm:{
    enabled:false,       // optional extra confirmation
    tfSeconds:3600,      // H1 by default
    emaFast:20,
    emaSlow:50,
    status:"OFF",
    lastUpdated:0,
    refreshMs:60000
  },
  tradeMgmt:{
    trailingTP:false,    // off by default to preserve behavior
    trailStart:0.15,     // start trailing after +$0.15
    trailStep:0.05,      // lock in +$0.05 increments
    breakEven:false,     // off by default
    beAt:0.12,           // move to BE after +$0.12
    beBuffer:0.01        // keep +$0.01 cushion
  },
  //  Accumulator (True ACCU) - optional scrape mode
  accu:{
    enabled:false,
    growthRate:0.01,      // 1%..5% (0.01..0.05)
    takeProfit:null,      // profit amount ($) for server-side auto-sell (limit_order.take_profit)
    safe:true             // caps growth to 12% when ON
  },



  // account
  isDemo: null
};

// ==== AI INTELLIGENCE LAYER START ====
// Safety-only AI Guard: can ONLY allow/block trades + extend cooldown. Never changes signals/strategy.
const aiLayer = {
  enabled: true,
  confidence: 100,
  regime: "NORMAL",           // NORMAL | CHOP | SPIKE | COOLING | DRAWDOWN
  lastBlockReason: "None",
  cooldownExtraUntil: 0,

  rolling: {
    prices: [],
    returns: [],
    vol: 0,
    volAvg: 0,
    volStd: 0
  },

  perf: {
    consecutiveLosses: 0,
    consecutiveWins: 0,
    lastTradeProfit: 0,
    blockCount: 0,
    allowCount: 0,
    lastDecisionAt: 0,
    tradeTimes: []
  },

  limits: {
    maxTradesPerMinute: 3,
    minConfidence: 55
  },

  _pruneOldTradeTimes(nowMs){
    const cutoff = nowMs - 60000;
    this.perf.tradeTimes = (this.perf.tradeTimes || []).filter(t => t >= cutoff);
  },

  _calcStats(){
    const rets = this.rolling.returns;
    if (!rets || rets.length < 5){
      this.rolling.vol = 0;
      this.rolling.volAvg = 0;
      this.rolling.volStd = 0;
      return;
    }
    const absVals = rets.map(v => Math.abs(v));
    const meanAbs = absVals.reduce((a,b)=>a+b,0) / absVals.length;

    // stddev of returns (not abs) for stability
    const mean = rets.reduce((a,b)=>a+b,0) / rets.length;
    const variance = rets.reduce((a,b)=>a + Math.pow(b-mean,2), 0) / rets.length;
    const std = Math.sqrt(variance);

    this.rolling.vol = meanAbs;
    this.rolling.volAvg = meanAbs; // keep naming explicit (mean abs)
    this.rolling.volStd = std;
  },

  onPriceTick(price, nowMs){
    if (!Number.isFinite(price)) return;

    const maxN = 60;
    const p = this.rolling.prices;
    const r = this.rolling.returns;

    if (p.length > 0){
      const prev = p[p.length - 1];
      const delta = price - prev;
      r.push(delta);
      if (r.length > maxN) r.shift();
    }

    p.push(price);
    if (p.length > maxN) p.shift();

    this._calcStats();

    // Regime guess (lightweight): detect CHOP if many flips with low net movement
    if (r.length >= 18){
      const lastN = r.slice(-18);
      const signs = lastN.map(v => (v > 0 ? 1 : (v < 0 ? -1 : 0)));
      let flips = 0;
      for (let i=1;i<signs.length;i++){
        if (signs[i] !== 0 && signs[i-1] !== 0 && signs[i] !== signs[i-1]) flips++;
      }
      const netMove = Math.abs(p[p.length-1] - p[Math.max(0, p.length-19)]);
      const typical = Math.max(this.rolling.volAvg * 18, 1e-9);

      // lots of flips, small net move -> chop
      if (flips >= 10 && netMove < typical * 0.45){
        if (this.regime !== "DRAWDOWN") this.regime = "CHOP";
      } else if (this.regime === "CHOP") {
        this.regime = "NORMAL";
      }
    }
  },

  onTradeClosed(finalProfitNumber, nowMs){
    const p = Number(finalProfitNumber) || 0;
    this.perf.lastTradeProfit = p;

    if (p < 0){
      this.perf.consecutiveLosses += 1;
      this.perf.consecutiveWins = 0;
    } else if (p > 0){
      this.perf.consecutiveWins += 1;
      this.perf.consecutiveLosses = 0;
    } else {
      // break streak on breakeven
      this.perf.consecutiveWins = 0;
      this.perf.consecutiveLosses = 0;
    }

    if (this.perf.consecutiveLosses >= 2){
      this.regime = "DRAWDOWN";
      // gentle cooldown after a loss streak
      this.cooldownExtraUntil = Math.max(this.cooldownExtraUntil, nowMs + 60000);
    } else if (this.regime === "DRAWDOWN" && this.perf.consecutiveLosses === 0){
      this.regime = "COOLING";
      this.cooldownExtraUntil = Math.max(this.cooldownExtraUntil, nowMs + 15000);
    }
  },

  shouldAllowTrade(ctx){
    const now = ctx?.now || Date.now();
    this.perf.lastDecisionAt = now;

    if (!this.enabled){
      this.lastBlockReason = "AI Guard OFF";
      return { allow: true };
    }

    // Respect AI cooldown
    if (now < (this.cooldownExtraUntil || 0)){
      this.perf.blockCount += 1;
      const sec = Math.ceil(((this.cooldownExtraUntil || 0) - now)/1000);
      return { allow: false, reason: `AI Cooldown (${sec}s)`, cooldownMs: 0 };
    }

    // Overtrading protection (final stage only)
    // Accumulator "SCRAPE/SCALP" needs fast re-entries.
    // Use a simple minimum gap (5s) instead of the per-minute cap to avoid getting "stuck".
    const isAccu = !!ctx?.accuEnabled;
    const isScrapeMode = /scalp|scrap|scrape/i.test(String(ctx?.mode || ""));
    if (isAccu && isScrapeMode){
      const tt = this.perf.tradeTimes || [];
      const last = tt.length ? tt[tt.length - 1] : 0;
      const minGap = 5000;
      if (last && (now - last) < minGap){
        this.perf.blockCount += 1;
        const sec = Math.max(1, Math.ceil((minGap - (now - last))/1000));
        return { allow:false, reason:`Overtrading Cooldown (${sec}s)`, cooldownMs: minGap };
      }
      // Keep history trimmed but don't enforce per-minute cap in scrape mode
      this._pruneOldTradeTimes(now);
    } else {
      this._pruneOldTradeTimes(now);
      const drawdown = this.perf.consecutiveLosses >= 2;

      const maxTPM = drawdown ? Math.max(1, Math.floor(this.limits.maxTradesPerMinute * 0.6)) : this.limits.maxTradesPerMinute;
      if ((this.perf.tradeTimes?.length || 0) >= maxTPM){
        this.regime = drawdown ? "DRAWDOWN" : this.regime;
        this.perf.blockCount += 1;
        return { allow:false, reason:`Overtrading Guard (${maxTPM}/min)`, cooldownMs: drawdown ? 90000 : 30000 };
      }
    }

// Rolling volatility checks
    const vol = this.rolling.vol || 0;
    const std = this.rolling.volStd || 0;

    // Adaptive spike threshold: if we have little history, avoid blocking too early
    const hasHistory = (this.rolling.returns?.length || 0) >= 18;
    const base = Math.max(vol, 1e-9);
    const spikeThr = hasHistory ? (base * 2.8 + std * 1.6) : Infinity;
    const flatThr  = hasHistory ? (base * 0.35) : -Infinity;

    // Compute "instant vol" (mean abs of last 10 returns)
    let instantVol = 0;
    if (this.rolling.returns && this.rolling.returns.length >= 10){
      const last10 = this.rolling.returns.slice(-10).map(v => Math.abs(v));
      instantVol = last10.reduce((a,b)=>a+b,0)/last10.length;
    } else {
      instantVol = vol;
    }

    if (hasHistory && instantVol > spikeThr){
      this.regime = "SPIKE";
      this.perf.blockCount += 1;
      return { allow:false, reason:"Volatility Spike", cooldownMs: 20000 };
    }

    if (hasHistory && instantVol < flatThr){
      // too flat often becomes chop/whipsaw
      if (this.regime !== "DRAWDOWN") this.regime = "CHOP";
    }

    // Confidence score (0-100) derived ONLY from vol normality + regime + streaks
    let conf = 100;

    // Regime penalty
    if (this.regime === "CHOP") conf -= 28;
    if (this.regime === "SPIKE") conf -= 45;
    if (this.regime === "COOLING") conf -= 18;
    if (this.regime === "DRAWDOWN") conf -= 35;

    // Streak penalty/bonus
    conf -= Math.min(30, this.perf.consecutiveLosses * 12);
    conf += Math.min(10, this.perf.consecutiveWins * 4);

    // Vol normality: penalize extremes a bit even if not spike-blocked
    if (hasHistory){
      const ratio = instantVol / Math.max(base, 1e-9);
      if (ratio > 2.0) conf -= 15;
      if (ratio < 0.55) conf -= 10;
    }

    conf = Math.max(0, Math.min(100, Math.round(conf)));
    this.confidence = conf;

    // Dynamic minimum confidence in drawdown / chop
    let minC = this.limits.minConfidence;
    if (this.regime === "CHOP") minC += 10;
    if (this.regime === "DRAWDOWN") minC += 15;

    if (conf < minC){
      this.perf.blockCount += 1;
      return { allow:false, reason:`Low Confidence (${conf}% < ${minC}%)`, cooldownMs: (this.regime === "DRAWDOWN") ? 90000 : 20000 };
    }

    // Allow — record only on FINAL stage to avoid double-count
// this.perf.allowCount += 1;
    if (ctx?.stage === "BEFORE_BUY"){
      this.perf.tradeTimes.push(now);
      this._pruneOldTradeTimes(now);
    }

    return { allow:true };
  }
};

/* =========================================================
   Chart Assist (FVG / Pullback / Double)   optional
   - BOOST mode: only shortens cooldown when a high-quality
     quick setup appears in the SAME direction the bot already
     wants to trade. (Does NOT change entry logic.)
   - GATE mode: can block entries when a strong reversal pattern
     conflicts with direction (optional; off by default).
========================================================= */

/* =========================================================
   Burst Protection + Soft Score helpers (optional)
   ========================================================= */
const burstProtect = {
  _lastPrice: null,
  _lastTriggerAt: 0,

  onTick(price, nowMs){
    const cfg = appState.burstProtect;
    if (!cfg || !cfg.enabled) return;

    if (this._lastPrice == null){
      this._lastPrice = price;
      return;
    }
    const dp = Math.abs(price - this._lastPrice);
    this._lastPrice = price;

    // Need enough rolling data for a stable baseline
    const base = Number(aiLayer.rolling?.volAvg || 0);
    const baseOk = Number.isFinite(base) && base > 0 && (aiLayer.rolling?.returns?.length || 0) >= 20;
    if (!baseOk) return;

    const spikeMult = Math.max(1, Number(cfg.spikeMult || 3.5));
    const refractory = Math.max(0, Number(cfg.refractoryS || 6)) * 1000;
    if (nowMs - (this._lastTriggerAt || 0) < refractory) return;

    // Spike if current delta is much larger than typical delta
    if (dp >= base * spikeMult){
      const minS = Math.max(0, Number(cfg.minCooldownS || 45));
      const maxS = Math.max(minS, Number(cfg.maxCooldownS || 120));
      const severity = Math.min(1, Math.max(0, (dp / (base * spikeMult)) - 1) / 2); // 0..1
      const cdS = Math.round(minS + severity * (maxS - minS));
      appState.burstCooldownUntil = Math.max(appState.burstCooldownUntil || 0, nowMs + cdS * 1000);
      this._lastTriggerAt = nowMs;

      if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "Burst Protection";
      logLine(`[Burst] Spike detected (Δ=${dp.toFixed(5)} base=${base.toFixed(5)}). Cooldown ${cdS}s`);
    }
  }
};

function computeSoftScore(direction){
  const cfg = appState.softScore;
  if (!cfg || !cfg.enabled) return { score: 100, reasons: ["OFF"] };

  let score = 100;
  const reasons = [];

  // Regime penalty (from AI layer)
  const regime = (aiLayer.regime || "NORMAL");
  if (regime === "CHOP"){ score -= 20; reasons.push("CHOP"); }
  else if (regime === "SPIKE"){ score -= 35; reasons.push("SPIKE"); }
  else if (regime === "COOLING"){ score -= 10; reasons.push("COOLING"); }
  else if (regime === "DRAWDOWN"){ score -= 15; reasons.push("DRAWDOWN"); }

  // Confidence penalty
  const conf = Number(aiLayer.confidence ?? 100);
  if (Number.isFinite(conf) && conf < 80){
    const p = Math.min(25, (80 - conf) * 0.6);
    score -= p;
    reasons.push("LowConf");
  }

  // Indicator alignment (Scalp Indicator Assist)
  const ind = chartAssist.indicatorScore ? chartAssist.indicatorScore(direction) : null;
  if (ind && Number.isFinite(ind.score)){
    // Reward alignment, penalize conflict
    const alignPenalty = Math.max(0, (60 - ind.score) * 0.35);
    score -= alignPenalty;
    if (alignPenalty > 0) reasons.push("IndWeak");
    if (Number.isFinite(ind.conflictPct) && ind.conflictPct >= (appState.scalpInd?.hardConflictPct ?? 70)){
      score -= 10;
      reasons.push("IndConflict");
    }
  }

  score = Math.max(0, Math.min(100, Math.round(score)));
  return { score, reasons };
}


const chartAssist = {
  lastSignal: null,
  lastSignalAt: 0,
  _lastClosedLen: 0,

  _atr(candles, n=20){
    if (!candles || candles.length < n+1) return null;
    const slice = candles.slice(-n);
    const trs = [];
    for (let i=1;i<slice.length;i++){
      const c = slice[i];
      const p = slice[i-1];
      const tr = Math.max(
        c.high - c.low,
        Math.abs(c.high - p.close),
        Math.abs(c.low - p.close)
      );
      trs.push(tr);
    }
    if (!trs.length) return null;
    return trs.reduce((a,b)=>a+b,0) / trs.length;
  },


  _smaVals(vals, n){
    if (!vals || vals.length < n) return null;
    let sum = 0;
    for (let i=vals.length-n;i<vals.length;i++) sum += vals[i];
    return sum / n;
  },
  _emaVals(vals, n){
    if (!vals || vals.length < n) return null;
    const k = 2 / (n + 1);
    let ema = vals[vals.length - n];
    for (let i=vals.length - n + 1; i<vals.length; i++){
      ema = (vals[i] * k) + (ema * (1 - k));
    }
    return ema;
  },
  _std(vals, n){
    if (!vals || vals.length < n) return null;
    const mean = this._smaVals(vals, n);
    let v = 0;
    for (let i=vals.length-n;i<vals.length;i++){
      const d = vals[i] - mean;
      v += d*d;
    }
    return Math.sqrt(v / n);
  },
  _rsi(vals, n){
    if (!vals || vals.length < n+1) return null;
    let gains = 0, losses = 0;
    for (let i=vals.length-n;i<vals.length;i++){
      const ch = vals[i] - vals[i-1];
      if (ch >= 0) gains += ch;
      else losses += (-ch);
    }
    const avgGain = gains / n;
    const avgLoss = losses / n;
    if (avgLoss === 0) return 100;
    const rs = avgGain / avgLoss;
    return 100 - (100 / (1 + rs));
  },
  _boll(vals, n, stdMult){
    if (!vals || vals.length < n) return null;
    const mid = this._smaVals(vals, n);
    const sd = this._std(vals, n);
    if (mid == null || sd == null) return null;
    const upper = mid + (sd * stdMult);
    const lower = mid - (sd * stdMult);
    return { mid, upper, lower, width:(upper-lower) };
  },
  _macd(vals, fast=12, slow=26, sig=9){
    if (!vals || vals.length < slow + sig + 2) return null;
    // build macd series for last (sig+5) points for stability
    const macdSeries = [];
    for (let i=0;i<vals.length;i++){
      const slice = vals.slice(0, i+1);
      if (slice.length < slow) continue;
      const emaFast = this._emaVals(slice, fast);
      const emaSlow = this._emaVals(slice, slow);
      if (emaFast == null || emaSlow == null) continue;
      macdSeries.push(emaFast - emaSlow);
    }
    if (macdSeries.length < sig + 2) return null;
    const signal = this._emaVals(macdSeries, sig);
    const macd = macdSeries[macdSeries.length-1];
    const hist = macd - signal;
    return { macd, signal, hist };
  },

  indicatorScore(direction){
    const cfg = appState.scalpInd;
    if (appState.mode !== "SCALP") return null;
    if (!cfg || !cfg.enabled) return null;

    const candles = appState.chart?.closedCandles || [];
    const closes = candles.map(c => c.close);
    const price = closes.length ? closes[closes.length-1] : Number(appState.lastTick);
    if (!Number.isFinite(price)) return null;

    const total = 4; // MA, BB, RSI, MACD (fixed for scoring)
    let aligns = 0;
    let conflicts = 0;
    const reasons = [];

    // MA trend/position
    const maN = Math.max(5, cfg.maPeriod||70);
    const maNow = this._smaVals(closes, maN);
    const maPrev = (closes.length > maN+1) ? this._smaVals(closes.slice(0, -1), maN) : null;
    const slope = (maNow!=null && maPrev!=null) ? (maNow - maPrev) : 0;
    if (maNow != null){
      const ok = (direction==="CALL") ? (price >= maNow && slope >= 0) : (price <= maNow && slope <= 0);
      if (ok){ aligns++; reasons.push("MA align"); }
      else { conflicts++; reasons.push("MA conflict"); }
    }

    // Bollinger Bands
    const bb = this._boll(closes, Math.max(5, cfg.bbPeriod||50), Number(cfg.bbStd||2));
    if (bb){
      const outsideUp = price > bb.upper;
      const outsideDn = price < bb.lower;
      let ok = true;
      if (direction==="CALL"){
        ok = !outsideUp && (price >= bb.mid);
      } else {
        ok = !outsideDn && (price <= bb.mid);
      }
      if (ok){ aligns++; reasons.push("BB align"); }
      else { conflicts++; reasons.push("BB conflict"); }
    }

    // RSI
    const rsi = this._rsi(closes, Math.max(5, cfg.rsiPeriod||14));
    if (rsi != null){
      let ok = true;
      if (direction==="CALL"){
        ok = (rsi >= 50 && rsi <= 75);
      } else {
        ok = (rsi <= 50 && rsi >= 25);
      }
      if (ok){ aligns++; reasons.push("RSI align"); }
      else { conflicts++; reasons.push("RSI conflict"); }
    }

    // MACD histogram
    const macd = this._macd(closes, cfg.macdFast||12, cfg.macdSlow||26, cfg.macdSignal||9);
    if (macd){
      const ok = (direction==="CALL") ? (macd.hist >= 0) : (macd.hist <= 0);
      if (ok){ aligns++; reasons.push("MACD align"); }
      else { conflicts++; reasons.push("MACD conflict"); }
    }

    const score = Math.round((aligns / total) * 100);
    const conflictPct = Math.round((conflicts / total) * 100);
    return { score, conflictPct, reasons };
  },

  _detectFVG(candles, price){
    if (!candles || candles.length < 6) return null;
    const lookback = Math.min(60, candles.length - 3);
    const atr = this._atr(candles, 20) || 0;
    const minGap = atr ? atr * 0.12 : 0; // adaptive
    for (let i=candles.length-3; i>=candles.length-lookback-3; i--){
      if (i < 0) break;
      const c1 = candles[i];
      const c2 = candles[i+1];
      const c3 = candles[i+2];
      if (!c1 || !c2 || !c3) continue;

      // Bullish FVG: c1.high < c3.low
      if (c1.high < c3.low){
        const gapLow = c1.high;
        const gapHigh = c3.low;
        const gap = gapHigh - gapLow;
        if (gap < minGap) continue;

        const inZone = (price >= gapLow && price <= gapHigh);
        const score = inZone ? 82 : 62;
        return { kind:"FVG_BULL", dir:"CALL", gapLow, gapHigh, inZone, score };
      }

      // Bearish FVG: c1.low > c3.high
      if (c1.low > c3.high){
        const gapLow = c3.high;
        const gapHigh = c1.low;
        const gap = gapHigh - gapLow;
        if (gap < minGap) continue;

        const inZone = (price >= gapLow && price <= gapHigh);
        const score = inZone ? 82 : 62;
        return { kind:"FVG_BEAR", dir:"PUT", gapLow, gapHigh, inZone, score };
      }
    }
    return null;
  },

  _swingPoints(candles, span=2){
    const highs = [];
    const lows  = [];
    for (let i=span; i<candles.length-span; i++){
      const c = candles[i];
      let isHigh = true, isLow = true;
      for (let j=1; j<=span; j++){
        if (candles[i-j].high >= c.high) isHigh = false;
        if (candles[i+j].high >  c.high) isHigh = false;
        if (candles[i-j].low  <= c.low)  isLow  = false;
        if (candles[i+j].low  <  c.low)  isLow  = false;
      }
      if (isHigh) highs.push({ i, price: c.high, time: c.time });
      if (isLow)  lows.push({ i, price: c.low,  time: c.time });
    }
    return { highs, lows };
  },

  _detectDouble(candles, price){
    if (!candles || candles.length < 18) return null;
    const atr = this._atr(candles, 20) || 0;
    const tol = atr ? atr * 0.18 : 0; // tolerance
    const { highs, lows } = this._swingPoints(candles.slice(-45), 2);
    // double top
    if (highs.length >= 2){
      const a = highs[highs.length-1];
      const b = highs[highs.length-2];
      if (Math.abs(a.price - b.price) <= tol && Math.abs(a.i - b.i) >= 4){
        const level = (a.price + b.price)/2;
        const near = tol ? Math.abs(price - level) <= tol*1.2 : false;
        const score = near ? 78 : 60;
        return { kind:"DOUBLE_TOP", dir:"PUT", level, near, score };
      }
    }
    // double bottom
    if (lows.length >= 2){
      const a = lows[lows.length-1];
      const b = lows[lows.length-2];
      if (Math.abs(a.price - b.price) <= tol && Math.abs(a.i - b.i) >= 4){
        const level = (a.price + b.price)/2;
        const near = tol ? Math.abs(price - level) <= tol*1.2 : false;
        const score = near ? 78 : 60;
        return { kind:"DOUBLE_BOTTOM", dir:"CALL", level, near, score };
      }
    }
    return null;
  },

  _detectImpulseBaseImpulse(candles, price){
    if (!candles || candles.length < 8) return null;
    const atr = this._atr(candles, 20) || 0;
    const minImpulse = atr ? atr * 0.55 : 0;
    const last = candles[candles.length-1];
    const c1 = candles[candles.length-4];
    const c2 = candles[candles.length-3];
    const c3 = candles[candles.length-2];
    if (!c1||!c2||!c3||!last) return null;

    const body1 = Math.abs(c1.close - c1.open);
    const body3 = Math.abs(c3.close - c3.open);
    const baseBody = Math.abs(c2.close - c2.open);

    if (minImpulse && (body1 < minImpulse || body3 < minImpulse)) return null;
    // base candle should be small
    if (atr && baseBody > atr * 0.25) return null;

    const dir = (c1.close > c1.open && c3.close > c3.open) ? "CALL"
              : (c1.close < c1.open && c3.close < c3.open) ? "PUT"
              : null;
    if (!dir) return null;
    return { kind:"IBI", dir, score: 70 };
  },

  analyze(price){
    const candles = appState.chart?.closedCandles || [];
    const cfg = appState.chartAssist;
    if (!cfg || !cfg.enabled) return null;

    const fvg = this._detectFVG(candles, price);
    const dbl = this._detectDouble(candles, price);
    const ibi = this._detectImpulseBaseImpulse(candles, price);

    // prefer: FVG pullback (inZone), then double near, then ibi
    let best = null;
    const candidates = [fvg, dbl, ibi].filter(Boolean);
    for (const c of candidates){
      if (!best || (c.score || 0) > (best.score || 0)) best = c;
    }

    if (best){
      this.lastSignal = best;
      this.lastSignalAt = Date.now();
    }
    return best;
  },

  // Called on each tick (cheap).
  onTick(price){
    const cfg = appState.chartAssist;
    if (!cfg || !cfg.enabled) return;

    // only re-analyze when candle history grows or every ~2s
    const candles = appState.chart?.closedCandles || [];
    const now = Date.now();
    const closedLen = candles.length;
    const should = (closedLen !== this._lastClosedLen) || (now - this.lastSignalAt > 2000);
    if (!should) return;
    this._lastClosedLen = closedLen;
    this.analyze(price);
  },

  // BOOST: shorten cooldown when signal aligns with current direction
  maybeBoostCooldown(direction, effectiveCooldownUntil){
    const cfg = appState.chartAssist;
    const indCfg = appState.scalpInd;

    const useChart = !!(cfg && cfg.enabled && cfg.mode === "BOOST");
    const useInd = !!(indCfg && indCfg.enabled && appState.mode === "SCALP" && (indCfg.mode || "BOOST_ONLY") === "BOOST_ONLY");
    if (!useChart && !useInd) return false;

    const price = Number(appState.lastTick);
    if (!Number.isFinite(price)) return false;

    let boosted = false;

    if (useChart){
      const sig = this.analyze(price);
      if (sig){
        // More permissive for ACCU scrape mode
        const isAccu = !!(appState.accu && appState.accu.enabled);
        const threshold = isAccu ? Math.max(55, (cfg.threshold || 70) - 15) : (cfg.threshold || 70);

        if ((sig.score || 0) >= threshold && (!sig.dir || sig.dir === direction)){
          boosted = true;
        }
      }
    }

    if (useInd){
      const ind = this.indicatorScore(direction);
      const minScore = Math.min(100, Math.max(0, Number(indCfg.boostMinScore ?? 60)));
      if (ind && (ind.score || 0) >= minScore){
        boosted = true;
      }
    }

    if (!boosted) return false;

    // shorten ONLY bot cooldown, never AI cooldown
    const minSec = useChart ? (Number(cfg.minCooldownSec) || 2) : 2;
    const minMs = Math.max(0, minSec * 1000);
    const target = Date.now() + minMs;
    if (appState.cooldownUntil > target){
      appState.cooldownUntil = target;
      if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "Cooldown (boosted)";
      return true;
    }
    return false;
  },

  // GATE: optional reversal conflict block
  shouldGate(direction){
    const cfg = appState.chartAssist;
    const indCfg = appState.scalpInd;

    const useChart = !!(cfg && cfg.enabled && cfg.mode === "GATE");
    const useInd = !!(indCfg && indCfg.enabled && appState.mode === "SCALP" && (indCfg.mode || "BOOST_ONLY") === "GATE");

    if (!useChart && !useInd) return { allow:true, reason:"" };

    const price = Number(appState.lastTick);
    if (!Number.isFinite(price)) return { allow:true, reason:"" };

    // Chart patterns gate: block when strong opposite setup appears
    if (useChart){
      const sig = this.analyze(price);
      if (sig){
        const threshold = cfg.threshold || 70;
        if ((sig.score || 0) >= threshold && sig.dir && sig.dir !== direction){
          return { allow:false, reason:`Chart Assist: ${sig.kind} conflict` };
        }
      }
    }

    // Indicator gate (SCALP only): block when indicators show strong conflict / weak alignment
    if (useInd){
      const ind = this.indicatorScore(direction);
      if (ind){
        const gateMin = Math.min(100, Math.max(0, Number(indCfg.gateMinScore ?? 40)));
        const hardConf = Math.min(100, Math.max(0, Number(indCfg.hardConflictScore ?? 20)));
        if ((ind.score || 0) < gateMin || (ind.conflictPct || 0) >= hardConf){
          return { allow:false, reason:`Indicators: score ${ind.score}% / conflict ${ind.conflictPct}%` };
        }
      }
    }

    return { allow:true, reason:"" };
  }
};



// UI helper (non-breaking)
function updateAIGuardUI(){
  try{
    const t = $("ai-guard-toggle");
    const s = $("ai-guard-status");
    if (t && typeof t.checked === "boolean" && aiLayer.enabled !== t.checked){
      // keep aiLayer in sync if something changed it without handler
      aiLayer.enabled = !!t.checked;
    }
    if (s){
      const onOff = aiLayer.enabled ? "ON" : "OFF";
      const conf = Number.isFinite(aiLayer.confidence) ? aiLayer.confidence : 0;
      const reg  = aiLayer.regime || "NORMAL";
      const last = aiLayer.lastBlockReason || "None";
      s.textContent = `AI: ${onOff} | Regime: ${reg} | Confidence: ${conf}% | Last: ${last}`;
    }
  } catch(_){}
}
// ==== AI INTELLIGENCE LAYER END ====

/* =========================================================
    SAFETY FEATURES MODULE (non-invasive)
   - Does NOT change signal logic (direction decision stays the same)
   - Only adds extra "allow/block" gates + trade management (optional)
========================================================= */

function _getClosedCandles(){
  return appState.chart?.closedCandles || [];
}

/*  Volatility Guard: blocks dead market + spike conditions */
function passesVolatilityGuard(){
  if (!appState.volGuard?.enabled) return true;

  //  Anti-stuck recovery: add a small internal cooldown so the bot keeps cycling
  // and you never have to "stop/start" to recover.
  const now = Date.now();
  if (appState.volGuard._cooldownUntil && now < appState.volGuard._cooldownUntil){
    const sec = Math.max(1, Math.ceil((appState.volGuard._cooldownUntil - now)/1000));
    if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = `Vol Guard: Cooling (${sec}s)`;
    return false;
  }

  const candles = _getClosedCandles();
  const lb = Math.max(10, appState.volGuard.lookbackCandles || 20);
  if (candles.length < lb + 2) return true;

  const recent = candles.slice(-lb);
  const ranges = recent.map(c => Math.max(0, (c.high - c.low)));
  const avgRange = ranges.reduce((a,b)=>a+b,0) / (ranges.length || 1);
  const last = ranges[ranges.length-1];

  // Dead Market (ONLY if user sets a positive deadMinRange)
  const deadMin = (typeof appState.volGuard.deadMinRange === "number") ? appState.volGuard.deadMinRange : 0;
  if (deadMin > 0 && avgRange <= deadMin){
    appState.volGuard._cooldownUntil = now + 8000;
    if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "Vol Guard: Dead Market";
    return false;
  }

  // Too Quiet (optional)  off by default so Vol 25 1s can still scrape normally.
  const blockTooQuiet = !!appState.volGuard.blockTooQuiet; // set true manually if you want this behavior
  const deadMult = (typeof appState.volGuard.deadMaxMult === "number") ? appState.volGuard.deadMaxMult : 0.35;
  if (blockTooQuiet && deadMult > 0 && avgRange > 0 && last < avgRange * deadMult){
    appState.volGuard._cooldownUntil = now + 6000;
    if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "Vol Guard: Too Quiet";
    return false;
  }

  // Spike (always on when Vol Guard enabled)
  const spikeMult = (typeof appState.volGuard.spikeMaxMult === "number") ? appState.volGuard.spikeMaxMult : 3.5;
  if (avgRange > 0 && last > avgRange * spikeMult){
    appState.volGuard._cooldownUntil = now + 12000;
    if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "Vol Guard: Spike";
    return false;
  }

  // optional AI volatility sanity (if available)
  try{
    const std = aiLayer?.rolling?.volStd || 0;
    const spike = aiLayer?.rolling?.spike || 0;
    if (spike > 0.9 || std > 999999){
      appState.volGuard._cooldownUntil = now + 12000;
      if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "Vol Guard: AI Spike";
      return false;
    }
  }catch(_){}

  return true;
}

/*  Candle Structure Checks: strong close, wick rejection, optional break+retest */
function passesCandleStructure(direction){
  if (!appState.candleChecks?.enabled) return true;
  const candles = _getClosedCandles();
  if (candles.length < 3) return true;

  const c = candles[candles.length-1];
  const prev = candles[candles.length-2];

  const range = Math.max(1e-9, c.high - c.low);
  const body  = Math.abs(c.close - c.open);
  const upperWick = c.high - Math.max(c.open, c.close);
  const lowerWick = Math.min(c.open, c.close) - c.low;

  // Strong close in direction
  if (appState.candleChecks.requireStrongClose){
    if (direction === "CALL"){
      const closeStrength = (c.close - c.low) / range;
      if (closeStrength < 0.65 || body < range*0.20){
        dom.blockReasonDisplay && (dom.blockReasonDisplay.textContent = "Candle: Weak Close (BUY)");
        return false;
      }
    }
    if (direction === "PUT"){
      const closeStrength = (c.high - c.close) / range;
      if (closeStrength < 0.65 || body < range*0.20){
        dom.blockReasonDisplay && (dom.blockReasonDisplay.textContent = "Candle: Weak Close (SELL)");
        return false;
      }
    }
  }

  // Wick rejection (avoid trap candles)
  if (appState.candleChecks.requireWickRejection){
    if (direction === "CALL"){
      // reject lower wick (buyers defended)
      if (lowerWick < range*0.20 || upperWick > range*0.55){
        dom.blockReasonDisplay && (dom.blockReasonDisplay.textContent = "Candle: No Rejection (BUY)");
        return false;
      }
    }
    if (direction === "PUT"){
      if (upperWick < range*0.20 || lowerWick > range*0.55){
        dom.blockReasonDisplay && (dom.blockReasonDisplay.textContent = "Candle: No Rejection (SELL)");
        return false;
      }
    }
  }

  // Optional Break + Retest (strict): require last candle breaks prior high/low and retests
  if (appState.candleChecks.requireBreakRetest){
    if (direction === "CALL"){
      const broke = c.close > prev.high;
      const retest = c.low <= prev.high;
      if (!(broke && retest)){
        dom.blockReasonDisplay && (dom.blockReasonDisplay.textContent = "Structure: No Break+Retest (BUY)");
        return false;
      }
    }
    if (direction === "PUT"){
      const broke = c.close < prev.low;
      const retest = c.high >= prev.low;
      if (!(broke && retest)){
        dom.blockReasonDisplay && (dom.blockReasonDisplay.textContent = "Structure: No Break+Retest (SELL)");
        return false;
      }
    }
  }

  return true;
}

/*  HTF Trend Confirm (optional). Uses ticks_history candles like H4 trend code. */
function requestHTFCandles(){
  if (!appState.htfConfirm?.enabled) return;
  if (!appState.ws || !appState.isAuthenticated) return;

  const now = Date.now();
  if (now - (appState.htfConfirm.lastUpdated||0) < (appState.htfConfirm.refreshMs||60000)) return;

  appState.htfConfirm.status = "LOADING";
  updateUI();

  const count = 120;
  const req = {
    ticks_history: appState.symbol,
    adjust_start_time: 1,
    count,
    end: "latest",
    style: "candles",
    granularity: appState.htfConfirm.tfSeconds
  };
  appState.htfConfirm.lastUpdated = now;
  appState.ws.send(JSON.stringify(req));
}

/* Hook into existing history handler by reading candles and updating HTF trend */
function _updateHTFTrendFromHistory(res){
  try{
    if (!appState.htfConfirm?.enabled) return;
    const candles = res?.history?.candles;
    if (!Array.isArray(candles) || candles.length < 60) return;

    const closes = candles.map(x => Number(x.close)).filter(x => Number.isFinite(x));
    const fast = calcEMA(closes, appState.htfConfirm.emaFast || 20);
    const slow = calcEMA(closes, appState.htfConfirm.emaSlow || 50);
    appState.htfConfirm.status = trendClassify(fast, slow);
  }catch(e){
    appState.htfConfirm.status = "ERROR";
  }
}

function htfAllows(direction){
  if (!appState.htfConfirm?.enabled) return true;
  const s = appState.htfConfirm.status;
  if (s === "LOADING") return false;
  if (direction === "CALL") return s === "BULL" || s === "NEUTRAL";
  if (direction === "PUT")  return s === "BEAR" || s === "NEUTRAL";
  return true;
}

/*  Trade Management (optional)
   - Break-even: if profit >= beAt then close if falls back to (0 + buffer)
   - Trailing TP: lock in profit as it rises (soft trailing)
*/
function initTradeMgmtForNewContract(){
  appState._mgmt = {
    entryTime: Date.now(),
    ticksElapsed: 0,
    lastSpotTime: null,
    peakProfit: 0,
    beActive: false,
    lockedProfit: null,
    lastProfit: null,
    weakCount: 0,
    goodCount: 0,
    ladderTarget: null
  };
}

function applyTradeManagement(currentProfit, contract){
  if (!appState._mgmt) initTradeMgmtForNewContract();
  const mg = appState._mgmt;

  mg.peakProfit = Math.max(mg.peakProfit || 0, currentProfit);

  // Track ticks/time while contract is open (avoid double counting using spot_time when available)
  if (contract){
    const st = contract.current_spot_time ?? contract.exit_tick_time ?? null;
    if (st != null){
      if (mg.lastSpotTime == null || st !== mg.lastSpotTime){
        mg.ticksElapsed = (mg.ticksElapsed || 0) + 1;
        mg.lastSpotTime = st;
      }
    } else {
      mg.ticksElapsed = (mg.ticksElapsed || 0) + 1;
    }
  }

  // Smart Take-Out (2 ticks early, then 1 tick near max duration; always exit at max duration)
  if (appState.smartTakeout?.enabled){
    const stCfg = appState.smartTakeout;
    const dur = Number(appState.duration) || 0;
    const unit = appState.durationUnit || "t";

    let elapsedPct = 0;
    let maxReached = false;

    if (dur > 0){
      if (unit === "t"){
        elapsedPct = (mg.ticksElapsed / dur) * 100;
        maxReached = mg.ticksElapsed >= dur;
      } else {
        const msMap = { s:1000, m:60000, h:3600000, d:86400000 };
        const maxMs = (msMap[unit] || 1000) * dur;
        const elapsedMs = Date.now() - (mg.entryTime || Date.now());
        elapsedPct = (elapsedMs / maxMs) * 100;
        maxReached = elapsedMs >= maxMs;
      }
    }

    const fallbackAt = Math.max(0, Math.min(100, Number(stCfg.fallbackAfterPct ?? 70)));
    let primaryTicks = Math.max(1, parseInt(stCfg.primaryTicks ?? 2) || 2);

    // Tick Ladder (optional): dynamic 1/2/3 target based on early "double-touch" momentum.
    // Only applies in SCALP mode + tick duration.
    if (appState.tickLadder?.enabled && appState.mode === "SCALP" && unit === "t" && dur > 0){
      const lad = appState.tickLadder;
      const startT = Math.max(1, parseInt(lad.startTicks ?? 1) || 1);
      const midT = Math.max(startT, parseInt(lad.midTicks ?? 2) || 2);
      const maxT = Math.max(midT, parseInt(lad.maxTicks ?? 3) || 3);
      const windowT = Math.max(1, parseInt(lad.quickWindowTicks ?? 3) || 3);
      const need = Math.max(1, parseInt(lad.doubleTouchCount ?? 2) || 2);

      if (mg.ladderTarget == null) mg.ladderTarget = startT;
      if (mg.goodCount == null) mg.goodCount = 0;

      // "good" tick = profit improved by > eps (deltaP computed above)
      const good = hasPrev && (deltaP > eps);

      if (mg.ticksElapsed <= windowT && currentProfit > 0){
        mg.goodCount = good ? (mg.goodCount + 1) : 0;
        if (mg.goodCount >= need) mg.ladderTarget = Math.max(mg.ladderTarget, maxT);
        else if (mg.goodCount >= 1) mg.ladderTarget = Math.max(mg.ladderTarget, midT);
      }
      primaryTicks = mg.ladderTarget;
    }

    const fallbackTicks = Math.max(1, parseInt(stCfg.fallbackTicks ?? 1) || 1);

    // Momentum-aware fallback (SCALP only): near the end of tick-duration trades, grab 1 tick if momentum stalls.
    const eps = 1e-9;
    const stallReq = Math.max(1, parseInt(stCfg.stallTicksRequired ?? 1) || 1);
    const prevP = mg.lastProfit;
    const hasPrev = (prevP != null);
    const deltaP = hasPrev ? (currentProfit - prevP) : 0;
    mg.lastProfit = currentProfit;

    // Track consecutive "weak" ticks (profit not improving).
    if (!mg.weakCount) mg.weakCount = 0;
    const momentumWeak = hasPrev && (deltaP <= eps);
    mg.weakCount = momentumWeak ? (mg.weakCount + 1) : 0;

    const isTickDuration = (unit === "t");
    const remainingTicks = (isTickDuration && dur > 0) ? (dur - mg.ticksElapsed) : null;

    // Only apply momentum-based fallback in SCALP mode (so other modes keep their original behavior).
    const fallbackByMomentum =
      (appState.mode === "SCALP" &&
       isTickDuration && dur > 0 &&
       remainingTicks <= 1 &&
       mg.ticksElapsed >= fallbackTicks &&
       currentProfit > 0 &&
       mg.weakCount >= stallReq);

    const targetTicks = ((elapsedPct >= fallbackAt) || fallbackByMomentum) ? fallbackTicks : primaryTicks;

    // Force exit when max duration is reached (if duration is set)
    if (dur > 0 && maxReached){
      dom.blockReasonDisplay && (dom.blockReasonDisplay.textContent = "Smart Take-Out: Max Duration");
      logLine(`Smart Take-Out: max duration reached (${unit}:${dur}). Selling.`);
      sellContract();
      return true;
    }

    // Take profit early once in profit and enough ticks have passed
    if (currentProfit > 0 && mg.ticksElapsed >= targetTicks){
      dom.blockReasonDisplay && (dom.blockReasonDisplay.textContent = `Smart Take-Out: + after ${mg.ticksElapsed}t`);
      logLine(`Smart Take-Out: profit +${currentProfit.toFixed(2)} after ${mg.ticksElapsed} tick(s) (target ${targetTicks}). Selling.`);
      sellContract();
      return true;
    }
  }

  // Break-even activation
  if (appState.tradeMgmt?.breakEven && !mg.beActive && currentProfit >= (appState.tradeMgmt.beAt || 0.12)){
    mg.beActive = true;
    mg.lockedProfit = Math.max(mg.lockedProfit ?? -999, (appState.tradeMgmt.beBuffer || 0.01));
  }

  // Trailing TP lock-in
  if (appState.tradeMgmt?.trailingTP && currentProfit >= (appState.tradeMgmt.trailStart || 0.15)){
    const step = Math.max(0.01, appState.tradeMgmt.trailStep || 0.05);
    const locked = Math.floor((currentProfit - step) / step) * step; // lock one step behind
    mg.lockedProfit = Math.max(mg.lockedProfit ?? -999, locked);
  }

  // Exit rule if lockedProfit exists and profit falls back to it
  if (mg.lockedProfit != null && currentProfit <= mg.lockedProfit){
    dom.blockReasonDisplay && (dom.blockReasonDisplay.textContent = "Mgmt: Locked Profit Hit");
    sellContract();
    return true;
  }
  return false;
}


/* =========================================================
   DOM
========================================================= */
const dom = {
  // status
  connectionStatus: $("connection-status"),
  accountTypeStatus: $("account-type-status"),
  tradeActiveStatus: $("trade-active-status"),
  h4TrendDisplay: $("h4-trend-display"),
  blockReasonDisplay: $("block-reason-display"),

  // AI Guard
  aiGuardToggle: $("ai-guard-toggle"),
  aiGuardStatus: $("ai-guard-status"),
  accountWarning: $("account-warning"),

  // balance
  balanceDisplay: $("current-balance-display"),
  profitDisplay: $("current-profit-display"),
  lossDisplay: $("current-loss-display"),
  sellableDisplay: $("sellable-display"),

  // controls
  toggleBotBtn: $("toggle-bot-btn"),
  unlockBtn: $("unlock-settings-btn"),
  modeSelect: $("mode-select"),
  modePill: $("mode-pill"),
  modeStatus: $("mode-status"),

  stakeInput: $("stakeAmount"),

  // Risk sizing (auto lot size)
  riskSizingToggle: $("riskSizingEnabled"),
  riskSizingPct: $("riskSizingPct"),
  riskSizingMin: $("riskSizingMin"),
  riskSizingMax: $("riskSizingMax"),
  riskStakePreview: $("riskStakePreview"),
  durationInput: $("duration"),
  durationUnitInput: $("durationUnit"),
  tpInput: $("tpUSD"),
  slInput: $("slUSD"),
  maxTradesInput: $("maxTradesPerSignal"),
  cooldownInput: $("cooldownDuration"),

  safeToggle: $("safe-mode-toggle"),
  safeIndicator: $("safe-mode-indicator"),
  safeStatus: $("safe-mode-status"),

  priceActionToggle: $("price-action-toggle"),
  priceActionIndicator: $("price-action-indicator"),
  priceActionStatus: $("price-action-status"),



  // Chart Assist
  chartAssistToggle: $("chart-assist-toggle"),
  chartAssistIndicator: $("chart-assist-indicator"),
  chartAssistMode: $("chart-assist-mode"),
  chartAssistMinCd: $("chart-assist-mincd"),
  chartAssistStatus: $("chart-assist-status"),
  autoResumeToggle: $("autoresume-toggle"),
  autoResumeIndicator: $("autoresume-indicator"),
  autoSellToggle: $("autosell-toggle"),
  autoSellIndicator: $("autosell-indicator"),

  smartTakeoutToggle: $("smart-takeout-toggle"),
  smartTakeoutIndicator: $("smart-takeout-indicator"),
  smartTakeoutPrimary: $("smart-takeout-primary"),
  smartTakeoutFallback: $("smart-takeout-fallback"),
  smartTakeoutFallbackPct: $("smart-takeout-fallbackpct"),
  smartTakeoutStallTicks: $("smart-takeout-stallticks"),
  smartTakeoutStatus: $("smart-takeout-status"),
  // Tick Ladder
  tickLadderToggle: $("tick-ladder-toggle"),
  tickLadderIndicator: $("tick-ladder-indicator"),
  tickLadderStart: $("tick-ladder-start"),
  tickLadderMid: $("tick-ladder-mid"),
  tickLadderMax: $("tick-ladder-max"),
  tickLadderWindow: $("tick-ladder-window"),
  tickLadderDTouch: $("tick-ladder-dtouch"),
  tickLadderStatus: $("tick-ladder-status"),

  // Burst Protection + Soft Score
  burstProtectToggle: $("burst-protect-toggle"),
  burstProtectIndicator: $("burst-protect-indicator"),
  burstProtectLookback: $("burst-protect-lookback"),
  burstProtectMult: $("burst-protect-mult"),
  burstProtectMinCd: $("burst-protect-mincd"),
  burstProtectMaxCd: $("burst-protect-maxcd"),
  burstProtectStatus: $("burst-protect-status"),

  softScoreToggle: $("soft-score-toggle"),
  softScoreIndicator: $("soft-score-indicator"),
  softScoreBlock: $("soft-score-block"),
  softScoreBoost: $("soft-score-boost"),
  softScoreBoostCd: $("soft-score-boostcd"),
  softScoreStatus: $("soft-score-status"),


  scalpIndToggle: $("scalp-ind-toggle"),
  scalpIndIndicator: $("scalp-ind-indicator"),
  scalpIndMode: $("scalp-ind-mode"),
  scalpIndMa: $("scalp-ind-ma"),
  scalpIndBBPeriod: $("scalp-ind-bbperiod"),
  scalpIndBBStd: $("scalp-ind-bbstd"),
  scalpIndRSI: $("scalp-ind-rsi"),
  scalpIndMacdFast: $("scalp-ind-mfast"),
  scalpIndMacdSlow: $("scalp-ind-mslow"),
  scalpIndMacdSig: $("scalp-ind-msig"),
  scalpIndBoostMin: $("scalp-ind-boostmin"),
  scalpIndGateMin: $("scalp-ind-gatemin"),
  scalpIndHardConf: $("scalp-ind-hardconf"),
  scalpIndStatus: $("scalp-ind-status"),



  // api + pw
  apiToken: $("api-token"),
  tokenError: $("token-error-message"),
  loginBadge: $("login-status-badge"),
  toggleVisibilityBtn: $("toggle-visibility-btn"),
  copyApiUrlBtn: $("copy-api-url-btn"),
  apiUrlText: $("api-url-text"),
  editHint: $("edit-hint"),
  pwInput: $("start-password"),
  pwError: $("pw-error-message"),

  // chart
  chartStatus: $("chart-status"),

  // insights
  analyzeBtn: $("analyze-market-btn"),
  riskBtn: $("assess-risk-btn"),
  geminiOut: $("gemini-output"),
  geminiLoading: $("gemini-loading-indicator"),

  // trade settings
  symbolSelect: $("symbolSelect"),
  currentSymbolLabel: $("currentSymbolLabel"),
  customSymbol: $("customSymbol"),
  applySymbolBtn: $("applySymbolBtn"),

  placeTradeBtn: $("placeTradeBtn"),
  clearHistoryBtn: $("clearHistoryBtn"),
  bulk3Btn: $("bulk3Btn"),
  bulk5Btn: $("bulk5Btn"),
  placeStakeLabel: $("placeStakeLabel"),
  bulk3Label: $("bulk3Label"),
  bulk5Label: $("bulk5Label"),
  autoTradingToggle: $("autoTradingToggle"),

  // clustering
  clusterAlert: $("cluster-alert"),
  clusterText: $("cluster-text"),

  // log controls
  clearLogBtn: $("clear-log-btn"),
  exportLogBtn: $("export-log-btn"),

  // tx log controls
  clearTxLogBtn: $("clear-txlog-btn"),
  exportTxLogBtn: $("export-txlog-btn"),

  // confidence
  confidenceBar: $("confidence-bar"),
  confidenceText: $("confidence-text"),
  confidenceNotes: $("confidence-notes"),
  signalPill: $("signal-pill"),

  // Session Limits UI
  sessLimitEnabled: $("sess-limit-enabled"),
  sessMaxProfit: $("sess-maxProfit"),
  sessMaxLoss: $("sess-maxLoss"),
  sessMaxTrades: $("sess-maxTrades"),
  sessMaxWins: $("sess-maxWins"),
  sessMaxLosses: $("sess-maxLosses"),
  sessLimitStatus: $("sess-limit-status"),
  sessCounts: $("sess-counts"),
  sessLimitReset: $("sess-limit-reset"),
  // accumulator (ACCU)
  accuToggle: $("accu-toggle"),
  accuSettings: $("accu-settings"),
  accuGrowth: $("accu-growth"),
  accuTP: $("accu-tp"),
  accuSafe: $("accu-safe"),

};

/* =========================================================
   UI helpers
========================================================= */
function setPill(el, text, cls){
  if (!el) return;
  el.textContent = text;
  if (el.className.includes("status-pill")) el.className = `status-pill ${cls}`;
  else el.className = `pill ${cls}`;
}

function updateConnection(status, cls){
  setPill(dom.connectionStatus, status, cls);
  updateLoginBadge();
}

function updateLoginBadge(){
  if (!dom.loginBadge || !dom.connectionStatus) return;
  const t = dom.connectionStatus.textContent || "";
  if (t === "CONNECTED") setPill(dom.loginBadge, "CONNECTED", "bg-emerald-600 text-white");
  else if (t.includes("ERROR") || t.includes("DISCONNECTED")) setPill(dom.loginBadge, "DISCONNECTED", "bg-red-800 text-white");
  else setPill(dom.loginBadge, "CONNECTING...", "bg-yellow-600 text-white animate-pulse");
}

function updateTradeStatus(text, cls="bg-slate-600 text-slate-300"){
  setPill(dom.tradeActiveStatus, text, cls);
}

function updateProfit(p){
  if (!dom.profitDisplay) return;
  dom.profitDisplay.textContent = p.toFixed(2);
  let color = "text-slate-300";
  if (p > 0) color = "text-emerald-400";
  if (p < 0) color = "text-red-400";
  dom.profitDisplay.className = `text-lg font-bold ${color}`;
}

function updateLoss(l){
  if (!dom.lossDisplay) return;
  dom.lossDisplay.textContent = l.toFixed(2);
  dom.lossDisplay.className = "text-lg font-bold text-red-300";
}


// ==================== Session Limits (TP/SL + W/L + Trades) ====================
function readNumSafe(el){
  if (!el) return null;
  const v = (el.value || "").trim();
  if (v === "") return null;
  const n = Number(v);
  return Number.isFinite(n) ? n : null;
}

function renderSessionLimitsUI(){
  if (dom.sessCounts){
    dom.sessCounts.textContent = `Trades: ${appState.sessionTrades} | Wins: ${appState.sessionWins} | Losses: ${appState.sessionLosses}`;
  }
  if (dom.sessLimitStatus){
    const onOff = appState.sessLimitsEnabled ? "ON" : "OFF";
    dom.sessLimitStatus.textContent = appState.sessStopReason ? `STOPPED: ${appState.sessStopReason}` : `Limits ${onOff}`;
  }
}

function syncSessionLimitsFromUI(){
  appState.sessLimitsEnabled = !!(dom.sessLimitEnabled && dom.sessLimitEnabled.checked);

  appState.sessMaxProfit  = readNumSafe(dom.sessMaxProfit);
  appState.sessMaxLoss    = readNumSafe(dom.sessMaxLoss);
  appState.sessMaxTrades  = readNumSafe(dom.sessMaxTrades);
  appState.sessMaxWins    = readNumSafe(dom.sessMaxWins);
  appState.sessMaxLosses  = readNumSafe(dom.sessMaxLosses);

  // Clear stop reason when toggling / editing
  if (!appState.sessLimitsEnabled) appState.sessStopReason = null;
  renderSessionLimitsUI();
}

function resetSessionLimits(){
  appState.sessionTrades = 0;
  appState.sessionWins = 0;
  appState.sessionLosses = 0;
  appState.sessStopReason = null;

  // Keep user limits inputs as-is, just reset counters
  renderSessionLimitsUI();
}

function checkSessionLimitsAndMaybeStop(){
  if (!appState.sessLimitsEnabled) return false;
  if (appState.sessStopReason) return true;

  const pnl = Number(appState.sessionProfit || 0);

  if (appState.sessMaxProfit != null && pnl >= appState.sessMaxProfit){
    appState.sessStopReason = `TP hit (${pnl.toFixed(2)} ≥ ${Number(appState.sessMaxProfit).toFixed(2)})`;
  } else if (appState.sessMaxLoss != null && pnl <= -Math.abs(appState.sessMaxLoss)){
    appState.sessStopReason = `SL hit (${pnl.toFixed(2)} ≤ -${Math.abs(appState.sessMaxLoss).toFixed(2)})`;
  } else if (appState.sessMaxTrades != null && appState.sessionTrades >= appState.sessMaxTrades){
    appState.sessStopReason = `Max trades hit (${appState.sessionTrades}/${appState.sessMaxTrades})`;
  } else if (appState.sessMaxWins != null && appState.sessionWins >= appState.sessMaxWins){
    appState.sessStopReason = `Max wins hit (${appState.sessionWins}/${appState.sessMaxWins})`;
  } else if (appState.sessMaxLosses != null && appState.sessionLosses >= appState.sessMaxLosses){
    appState.sessStopReason = `Max losses hit (${appState.sessionLosses}/${appState.sessMaxLosses})`;
  }

  if (appState.sessStopReason){
    renderSessionLimitsUI();
    // Hard stop using existing stop function (do not change trading logic)
    try { stopBot(); } catch(e){}
    return true;
  }

  renderSessionLimitsUI();
  return false;
}
// ============================================================================

function setSellable(isSellable){
  appState.is_sellable = isSellable;
  if (isSellable === 1) setPill(dom.sellableDisplay, "YES", "bg-emerald-600 text-white");
  else setPill(dom.sellableDisplay, "NO", "bg-red-500 text-white");
}

function setIfNotEditing(el, value){
  if (!el) return;
  if (document.activeElement === el) return;
  el.value = value;
}

function updateTrendUI(){
  if (!dom.h4TrendDisplay) return;
  const t = appState.trend.enabled ? appState.trend.status : "OFF";
  let cls = "bg-slate-600 text-slate-300";
  if (t === "BULL") cls = "bg-emerald-600 text-white";
  if (t === "BEAR") cls = "bg-red-600 text-white";
  if (t === "NEUTRAL") cls = "bg-yellow-600 text-white";
  if (t === "ERROR") cls = "bg-red-800 text-white";
  if (t === "LOADING") cls = "bg-indigo-700 text-white";
  setPill(dom.h4TrendDisplay, t, cls);
}

function getEffectiveStake(){
  const manual = Number(appState.stakeAmount) || 0;
  const rs = appState.riskSizing;
  if (rs && rs.enabled){
    const bal = Number(appState.currentBalance) || 0;
    const pct = Number(rs.pct) || 0;
    let stake = (bal > 0 && pct > 0) ? (bal * pct / 100) : manual;
    const min = Number(rs.minStake) || 0;
    const max = Number(rs.maxStake) || 0;
    if (min > 0) stake = Math.max(stake, min);
    if (max > 0) stake = Math.min(stake, max);
    stake = Math.round(stake * 100) / 100;
    if (Number.isFinite(stake) && stake > 0) return stake;
  }
  return manual;
}

function updateUI(){
  if (dom.modePill) dom.modePill.textContent = appState.mode;
  if (dom.modeStatus) dom.modeStatus.textContent = appState.mode;

  if (dom.safeIndicator){
    dom.safeIndicator.textContent = appState.isSafeMode ? "ON" : "OFF";
    dom.safeIndicator.className = `pill ${appState.isSafeMode ? "bg-emerald-600" : "bg-red-600"} text-white`;
  }
  if (dom.safeStatus){
    dom.safeStatus.textContent = appState.isSafeMode
      ? "Safe Mode is ENABLED. Stop-loss selling is allowed."
      : "Safe Mode is DISABLED.";
  }

  if (dom.priceActionToggle && appState.candleChecks){
    dom.priceActionToggle.checked = !!appState.candleChecks.enabled;
  }
  if (dom.priceActionIndicator){
    const on = !!(appState.candleChecks && appState.candleChecks.enabled);
    dom.priceActionIndicator.textContent = on ? "ON" : "OFF";
    dom.priceActionIndicator.className = `pill ${on ? "bg-emerald-600" : "bg-red-600"} text-white`;
  }
  if (dom.priceActionStatus){
    const on = !!(appState.candleChecks && appState.candleChecks.enabled);
    dom.priceActionStatus.textContent = on ? "Price Action Filter is ENABLED." : "Price Action Filter is DISABLED.";
  }

  // Chart Assist UI
  if (dom.chartAssistToggle && appState.chartAssist){
    dom.chartAssistToggle.checked = !!appState.chartAssist.enabled;
  }
  if (dom.chartAssistIndicator && appState.chartAssist){
    const on = !!appState.chartAssist.enabled;
    dom.chartAssistIndicator.textContent = on ? "ON" : "OFF";
    dom.chartAssistIndicator.className = `pill ${on ? "bg-emerald-600" : "bg-red-600"} text-white`;
  }
  if (dom.chartAssistStatus && appState.chartAssist){
    const on = !!appState.chartAssist.enabled;
    const sig = chartAssist?.lastSignal;
    if (!on){
      dom.chartAssistStatus.textContent = "Chart Assist is currently OFF.";
    } else if (sig){
      const age = Math.floor((Date.now() - (chartAssist.lastSignalAt||Date.now()))/1000);
      dom.chartAssistStatus.textContent = `Signal: ${sig.kind} (${sig.dir}) | Score ${sig.score||0} | ${age}s ago`;
    } else {
      dom.chartAssistStatus.textContent = "Chart Assist is ON. Scanning...";
    }
  }
  if (dom.chartAssistMode && appState.chartAssist && document.activeElement !== dom.chartAssistMode){
    dom.chartAssistMode.value = appState.chartAssist.mode || "BOOST";
  }
  setIfNotEditing(dom.chartAssistMinCd, String(appState.chartAssist?.minCooldownSec ?? 2));



  setIfNotEditing(dom.stakeInput, appState.stakeAmount.toFixed(2));

  // Risk sizing UI
  if (!appState.riskSizing) appState.riskSizing = { enabled:false, pct:1, minStake:0.35, maxStake:0 };
  if (dom.riskSizingToggle) dom.riskSizingToggle.checked = !!appState.riskSizing.enabled;
  setIfNotEditing(dom.riskSizingPct, String(appState.riskSizing.pct ?? 1));
  setIfNotEditing(dom.riskSizingMin, String(appState.riskSizing.minStake ?? 0.35));
  setIfNotEditing(dom.riskSizingMax, String(appState.riskSizing.maxStake ?? 0));
  if (dom.riskStakePreview){
    if (appState.riskSizing.enabled){
      const eff = getEffectiveStake();
      const bal = Number(appState.currentBalance) || 0;
      const pct = Number(appState.riskSizing.pct) || 0;
      dom.riskStakePreview.textContent = `Auto stake: $${eff.toFixed(2)} (${pct}% of $${bal.toFixed(2)})`;
    } else {
      dom.riskStakePreview.textContent = "Auto stake: OFF";
    }
  }
  setIfNotEditing(dom.durationInput, String(appState.duration));
  if (dom.durationUnitInput && document.activeElement !== dom.durationUnitInput) dom.durationUnitInput.value = appState.durationUnit;
  setIfNotEditing(dom.tpInput, appState.tpUSD.toFixed(2));
  setIfNotEditing(dom.slInput, appState.slUSD.toFixed(2));
  setIfNotEditing(dom.maxTradesInput, String(appState.maxTradesPerSignal));
  setIfNotEditing(dom.cooldownInput, String(appState.cooldownDuration));

  if (dom.modeSelect && document.activeElement !== dom.modeSelect) dom.modeSelect.value = appState.mode;
  if (dom.safeToggle && document.activeElement !== dom.safeToggle) dom.safeToggle.checked = appState.isSafeMode;

  if (dom.autoResumeIndicator){
    dom.autoResumeIndicator.textContent = appState.autoResume ? "ON" : "OFF";
    dom.autoResumeIndicator.className = `pill ${appState.autoResume ? "bg-emerald-600" : "bg-red-600"} text-white`;
  }
  if (dom.autoResumeToggle) dom.autoResumeToggle.checked = !!appState.autoResume;

  if (dom.autoSellIndicator){
    dom.autoSellIndicator.textContent = appState.autoSellEnabled ? "ON" : "OFF";
    dom.autoSellIndicator.className = `pill ${appState.autoSellEnabled ? "bg-emerald-600" : "bg-red-600"} text-white`;
  }
  if (dom.autoSellToggle) dom.autoSellToggle.checked = !!appState.autoSellEnabled;

  // Smart Take-Out UI
  if (dom.smartTakeoutIndicator && appState.smartTakeout){
    const on = !!appState.smartTakeout.enabled;
    dom.smartTakeoutIndicator.textContent = on ? "ON" : "OFF";
    dom.smartTakeoutIndicator.className = `pill ${on ? "bg-emerald-600" : "bg-red-600"} text-white`;
  }
  if (dom.smartTakeoutToggle && appState.smartTakeout){
    dom.smartTakeoutToggle.checked = !!appState.smartTakeout.enabled;
  }
  setIfNotEditing(dom.smartTakeoutPrimary, String(appState.smartTakeout?.primaryTicks ?? 2));
  setIfNotEditing(dom.smartTakeoutFallback, String(appState.smartTakeout?.fallbackTicks ?? 1));
  setIfNotEditing(dom.smartTakeoutFallbackPct, String(appState.smartTakeout?.fallbackAfterPct ?? 70));
  setIfNotEditing(dom.smartTakeoutStallTicks, String(appState.smartTakeout?.stallTicksRequired ?? 1));


  // Tick Ladder UI
  if (dom.tickLadderIndicator && appState.tickLadder){
    const on = !!appState.tickLadder.enabled;
    dom.tickLadderIndicator.textContent = on ? "ON" : "OFF";
    dom.tickLadderIndicator.className = `pill ${on ? "bg-emerald-600" : "bg-red-600"} text-white`;
  }
  if (dom.tickLadderToggle && appState.tickLadder){
    dom.tickLadderToggle.checked = !!appState.tickLadder.enabled;
  }
  setIfNotEditing(dom.tickLadderStart, String(appState.tickLadder?.startTicks ?? 1));
  setIfNotEditing(dom.tickLadderMid, String(appState.tickLadder?.midTicks ?? 2));
  setIfNotEditing(dom.tickLadderMax, String(appState.tickLadder?.maxTicks ?? 3));
  setIfNotEditing(dom.tickLadderWindow, String(appState.tickLadder?.quickWindowTicks ?? 3));
  setIfNotEditing(dom.tickLadderDTouch, String(appState.tickLadder?.doubleTouchCount ?? 2));
  if (dom.tickLadderStatus && appState.tickLadder){
    dom.tickLadderStatus.textContent = appState.tickLadder.enabled ? "Tick Ladder is ON." : "Tick Ladder is OFF.";
  }

  // Burst Protection UI
  if (dom.burstProtectIndicator && appState.burstProtect){
    const on = !!appState.burstProtect.enabled;
    dom.burstProtectIndicator.textContent = on ? "ON" : "OFF";
    dom.burstProtectIndicator.className = `pill ${on ? "bg-emerald-600" : "bg-red-600"} text-white`;
  }
  if (dom.burstProtectToggle && appState.burstProtect){
    dom.burstProtectToggle.checked = !!appState.burstProtect.enabled;
  }
  setIfNotEditing(dom.burstProtectLookback, String(appState.burstProtect?.lookback ?? 40));
  setIfNotEditing(dom.burstProtectMult, String(appState.burstProtect?.spikeMult ?? 3.5));
  setIfNotEditing(dom.burstProtectMinCd, String(appState.burstProtect?.minCooldownS ?? 45));
  setIfNotEditing(dom.burstProtectMaxCd, String(appState.burstProtect?.maxCooldownS ?? 120));
  if (dom.burstProtectStatus && appState.burstProtect){
    dom.burstProtectStatus.textContent = appState.burstProtect.enabled ? "Burst Protection is ON." : "Burst Protection is OFF.";
  }

  // Soft Score UI
  if (dom.softScoreIndicator && appState.softScore){
    const on = !!appState.softScore.enabled;
    dom.softScoreIndicator.textContent = on ? "ON" : "OFF";
    dom.softScoreIndicator.className = `pill ${on ? "bg-emerald-600" : "bg-red-600"} text-white`;
  }
  if (dom.softScoreToggle && appState.softScore){
    dom.softScoreToggle.checked = !!appState.softScore.enabled;
  }
  setIfNotEditing(dom.softScoreBlock, String(appState.softScore?.blockBelow ?? 45));
  setIfNotEditing(dom.softScoreBoost, String(appState.softScore?.boostBelow ?? 60));
  setIfNotEditing(dom.softScoreBoostCd, String(appState.softScore?.boostCooldownS ?? 20));
  if (dom.softScoreStatus && appState.softScore){
    dom.softScoreStatus.textContent = appState.softScore.enabled ? "Soft Score is ON." : "Soft Score is OFF.";
  }


  // Scalp Indicator Assist UI
  if (dom.scalpIndToggle && appState.scalpInd){
    dom.scalpIndToggle.checked = !!appState.scalpInd.enabled;
  }
  if (dom.scalpIndIndicator && appState.scalpInd){
    const on = !!appState.scalpInd.enabled;
    dom.scalpIndIndicator.textContent = on ? "ON" : "OFF";
    dom.scalpIndIndicator.className = `pill ${on ? "bg-emerald-600" : "bg-red-600"} text-white`;
  }
  if (dom.scalpIndStatus && appState.scalpInd){
    const on = !!appState.scalpInd.enabled;
    if (!on){
      dom.scalpIndStatus.textContent = "Scalp Indicator Assist is DISABLED.";
    } else {
      dom.scalpIndStatus.textContent = `Scalp Indicator Assist is ON (${appState.scalpInd.mode || "BOOST_ONLY"}).`;
    }
  }
  if (dom.scalpIndMode && appState.scalpInd && document.activeElement !== dom.scalpIndMode){
    dom.scalpIndMode.value = appState.scalpInd.mode || "BOOST_ONLY";
  }
  setIfNotEditing(dom.scalpIndMa, String(appState.scalpInd?.maPeriod ?? 70));
  setIfNotEditing(dom.scalpIndBBPeriod, String(appState.scalpInd?.bbPeriod ?? 50));
  setIfNotEditing(dom.scalpIndBBStd, String(appState.scalpInd?.bbStd ?? 2));
  setIfNotEditing(dom.scalpIndRSI, String(appState.scalpInd?.rsiPeriod ?? 14));
  setIfNotEditing(dom.scalpIndMacdFast, String(appState.scalpInd?.macdFast ?? 12));
  setIfNotEditing(dom.scalpIndMacdSlow, String(appState.scalpInd?.macdSlow ?? 26));
  setIfNotEditing(dom.scalpIndMacdSig, String(appState.scalpInd?.macdSignal ?? 9));
  setIfNotEditing(dom.scalpIndBoostMin, String(appState.scalpInd?.boostMinScore ?? 60));
  setIfNotEditing(dom.scalpIndGateMin, String(appState.scalpInd?.gateMinScore ?? 40));
  setIfNotEditing(dom.scalpIndHardConf, String(appState.scalpInd?.hardConflictScore ?? 20));
  if (dom.smartTakeoutStatus && appState.smartTakeout){
    const on = !!appState.smartTakeout.enabled;
    dom.smartTakeoutStatus.textContent = on
      ? `Smart Take-Out ON: targets ${appState.smartTakeout.primaryTicks} ticks early, then ${appState.smartTakeout.fallbackTicks} tick(s) after ${appState.smartTakeout.fallbackAfterPct}% of max duration.`
      : "Smart Take-Out is OFF.";
  }


  updateTrendUI();

  if (dom.currentSymbolLabel) dom.currentSymbolLabel.textContent = appState.symbol;
  const effStakeForLabels = getEffectiveStake();
  if (dom.placeStakeLabel) dom.placeStakeLabel.textContent = `$${effStakeForLabels.toFixed(2)}`;
  if (dom.bulk3Label) dom.bulk3Label.textContent = `$${(effStakeForLabels*3).toFixed(2)}`;
  if (dom.bulk5Label) dom.bulk5Label.textContent = `$${(effStakeForLabels*5).toFixed(2)}`;

  if (dom.accountTypeStatus){
    if (appState.isDemo === true) setPill(dom.accountTypeStatus, "DEMO", "bg-yellow-600 text-white");
    else if (appState.isDemo === false) setPill(dom.accountTypeStatus, "REAL", "bg-emerald-700 text-white");
    else setPill(dom.accountTypeStatus, "UNKNOWN", "bg-slate-600 text-slate-300");
  }

  if (dom.toggleBotBtn){
    if (appState.isBotRunning){
      dom.toggleBotBtn.textContent = "STOP BOT";
      dom.toggleBotBtn.className = "w-full py-3 rounded-lg font-bold transition duration-200 bg-red-600 hover:bg-red-700 text-white shadow-lg";
    } else {
      dom.toggleBotBtn.textContent = "START BOT";
      dom.toggleBotBtn.className = "w-full py-3 rounded-lg font-bold transition duration-200 bg-emerald-600 hover:bg-emerald-700 text-white shadow-lg";
    }
  }


  // Accumulator UI sync (True ACCU)
  if (dom.accuToggle && document.activeElement !== dom.accuToggle) dom.accuToggle.checked = !!appState.accu.enabled;
  if (dom.accuSettings) dom.accuSettings.style.display = appState.accu.enabled ? "grid" : "none";
  if (dom.accuSafe && document.activeElement !== dom.accuSafe) dom.accuSafe.checked = !!appState.accu.safe;
  if (dom.accuGrowth && document.activeElement !== dom.accuGrowth) dom.accuGrowth.value = String(appState.accu.growthRate || 0.01);
  if (dom.accuTP && document.activeElement !== dom.accuTP) dom.accuTP.value = appState.accu.takeProfit ? String(appState.accu.takeProfit) : "";
  // highlight growth buttons
  try{
    const cur = Number(appState.accu.growthRate || 0.01);
    document.querySelectorAll("[data-accu-growth]").forEach(btn => {
      const v = Number(btn.getAttribute("data-accu-growth"));
      const isOn = Math.abs(v - cur) < 1e-9;
      btn.classList.toggle("bg-sky-600", isOn);
      btn.classList.toggle("text-white", isOn);
      btn.classList.toggle("bg-slate-700", !isOn);
      btn.classList.toggle("text-slate-200", !isOn);
    });
  }catch(_){ }

  updateLoginBadge();
  updateConfidenceUI();
  updateLoss(appState.sessionLoss);
  updateAIGuardUI();
}

/* =========================================================
   Lock/Unlock settings
========================================================= */
function setSettingsLock(isLocked){
  appState.isSettingsLocked = isLocked;

  const list = [
    dom.stakeInput, dom.durationInput, dom.durationUnitInput,
    dom.riskSizingToggle, dom.riskSizingPct, dom.riskSizingMin, dom.riskSizingMax,
    dom.tpInput, dom.slInput, dom.maxTradesInput, dom.cooldownInput,
    dom.modeSelect, dom.safeToggle, dom.priceActionToggle, dom.autoResumeToggle, dom.autoSellToggle,
    dom.smartTakeoutToggle, dom.smartTakeoutPrimary, dom.smartTakeoutFallback, dom.smartTakeoutFallbackPct, dom.smartTakeoutStallTicks,
    dom.tickLadderToggle, dom.tickLadderStart, dom.tickLadderMid, dom.tickLadderMax, dom.tickLadderWindow, dom.tickLadderDTouch,
    dom.burstProtectToggle, dom.burstProtectLookback, dom.burstProtectMult, dom.burstProtectMinCd, dom.burstProtectMaxCd,
    dom.softScoreToggle, dom.softScoreBlock, dom.softScoreBoost, dom.softScoreBoostCd,
    dom.scalpIndToggle, dom.scalpIndMode, dom.scalpIndMa, dom.scalpIndBBPeriod, dom.scalpIndBBStd,
    dom.scalpIndRSI, dom.scalpIndMacdFast, dom.scalpIndMacdSlow, dom.scalpIndMacdSig,
    dom.scalpIndBoostMin, dom.scalpIndGateMin, dom.scalpIndHardConf,
    dom.chartAssistToggle, dom.chartAssistMode, dom.chartAssistMinCd,
    dom.accuToggle, dom.accuSafe, dom.accuTP, dom.accuGrowth,
    dom.sessLimitEnabled, dom.sessMaxProfit, dom.sessMaxLoss, dom.sessMaxTrades, dom.sessMaxWins, dom.sessMaxLosses, dom.sessLimitReset
  ].filter(Boolean);

    list.forEach(el => {
    // Some inputs are styled as toggles (sr-only + peer). Disabled is enough, but
    // Safari can keep focus; force blur on lock.
    try{ if (isLocked && document.activeElement === el) el.blur(); }catch(_){}
    el.disabled = isLocked;
  });

  // Accumulator growth buttons are not native inputs; lock the whole Accu settings box.
  if (dom.accuSettings){
    dom.accuSettings.classList.toggle("pointer-events-none", isLocked);
    dom.accuSettings.classList.toggle("opacity-60", isLocked);
  }

  if (dom.unlockBtn){
    dom.unlockBtn.textContent = isLocked ? "Unlock" : "Lock";
    dom.unlockBtn.className = isLocked
      ? "text-sm text-pink-400 hover:text-pink-300 font-medium py-1 px-3 rounded-full border border-pink-500 transition duration-150"
      : "text-sm text-white bg-pink-600 hover:bg-pink-700 font-medium py-1 px-3 rounded-full border border-pink-700 transition duration-150";
  }
}

/* =========================================================
   Input -> state (LIVE typing)
========================================================= */
function updateStateFromUI(){
  try{
    if (dom.stakeInput) appState.stakeAmount = parseFloat(dom.stakeInput.value) || 0;
    // Risk-based stake sizing
    if (!appState.riskSizing) appState.riskSizing = { enabled:false, pct:1, minStake:0.35, maxStake:0 };
    if (dom.riskSizingToggle) appState.riskSizing.enabled = !!dom.riskSizingToggle.checked;
    if (dom.riskSizingPct) appState.riskSizing.pct = Math.max(0, Math.min(100, parseFloat(dom.riskSizingPct.value) || 0));
    if (dom.riskSizingMin) appState.riskSizing.minStake = Math.max(0, parseFloat(dom.riskSizingMin.value) || 0);
    if (dom.riskSizingMax) appState.riskSizing.maxStake = Math.max(0, parseFloat(dom.riskSizingMax.value) || 0);

    if (dom.durationInput) appState.duration = parseInt(dom.durationInput.value) || 0;
    if (dom.durationUnitInput) appState.durationUnit = dom.durationUnitInput.value;
    if (dom.tpInput) appState.tpUSD = parseFloat(dom.tpInput.value) || 0;
    if (dom.slInput) appState.slUSD = parseFloat(dom.slInput.value) || 0;
    if (dom.maxTradesInput) appState.maxTradesPerSignal = parseInt(dom.maxTradesInput.value) || 0;
    if (dom.cooldownInput) appState.cooldownDuration = parseInt(dom.cooldownInput.value) || 0;

    if (dom.autoResumeToggle) appState.autoResume = !!dom.autoResumeToggle.checked;
    if (dom.autoSellToggle) appState.autoSellEnabled = !!dom.autoSellToggle.checked;
    // Smart Take-Out
    if (!appState.smartTakeout) appState.smartTakeout = { enabled:false, primaryTicks:2, fallbackTicks:1, fallbackAfterPct:70 };
    if (dom.smartTakeoutToggle) appState.smartTakeout.enabled = !!dom.smartTakeoutToggle.checked;
    if (dom.smartTakeoutPrimary) appState.smartTakeout.primaryTicks = Math.max(1, parseInt(dom.smartTakeoutPrimary.value) || 2);
    if (dom.smartTakeoutFallback) appState.smartTakeout.fallbackTicks = Math.max(1, parseInt(dom.smartTakeoutFallback.value) || 1);
    if (dom.smartTakeoutFallbackPct) appState.smartTakeout.fallbackAfterPct = Math.max(0, Math.min(100, parseFloat(dom.smartTakeoutFallbackPct.value) || 70));
    if (dom.smartTakeoutStallTicks) appState.smartTakeout.stallTicksRequired = Math.max(1, parseInt(dom.smartTakeoutStallTicks.value) || 1);

    // Tick Ladder
    if (!appState.tickLadder) appState.tickLadder = { enabled:false, startTicks:1, midTicks:2, maxTicks:3, quickWindowTicks:3, doubleTouchCount:2 };
    if (dom.tickLadderToggle) appState.tickLadder.enabled = !!dom.tickLadderToggle.checked;
    if (dom.tickLadderStart) appState.tickLadder.startTicks = Math.max(1, parseInt(dom.tickLadderStart.value) || 1);
    if (dom.tickLadderMid) appState.tickLadder.midTicks = Math.max(1, parseInt(dom.tickLadderMid.value) || 2);
    if (dom.tickLadderMax) appState.tickLadder.maxTicks = Math.max(1, parseInt(dom.tickLadderMax.value) || 3);
    if (dom.tickLadderWindow) appState.tickLadder.quickWindowTicks = Math.max(1, parseInt(dom.tickLadderWindow.value) || 3);
    if (dom.tickLadderDTouch) appState.tickLadder.doubleTouchCount = Math.max(1, parseInt(dom.tickLadderDTouch.value) || 2);

    // Burst Protection
    if (!appState.burstProtect) appState.burstProtect = { enabled:false, lookback:40, spikeMult:3.5, minCooldownS:45, maxCooldownS:120, refractoryS:6 };
    if (dom.burstProtectToggle) appState.burstProtect.enabled = !!dom.burstProtectToggle.checked;
    if (dom.burstProtectLookback) appState.burstProtect.lookback = Math.max(10, parseInt(dom.burstProtectLookback.value) || 40);
    if (dom.burstProtectMult) appState.burstProtect.spikeMult = Math.max(1, Math.min(10, parseFloat(dom.burstProtectMult.value) || 3.5));
    if (dom.burstProtectMinCd) appState.burstProtect.minCooldownS = Math.max(0, parseInt(dom.burstProtectMinCd.value) || 45);
    if (dom.burstProtectMaxCd) appState.burstProtect.maxCooldownS = Math.max(0, parseInt(dom.burstProtectMaxCd.value) || 120);

    // Soft Score
    if (!appState.softScore) appState.softScore = { enabled:false, blockBelow:45, boostBelow:60, boostCooldownS:20 };
    if (dom.softScoreToggle) appState.softScore.enabled = !!dom.softScoreToggle.checked;
    if (dom.softScoreBlock) appState.softScore.blockBelow = Math.max(0, Math.min(100, parseInt(dom.softScoreBlock.value) || 45));
    if (dom.softScoreBoost) appState.softScore.boostBelow = Math.max(0, Math.min(100, parseInt(dom.softScoreBoost.value) || 60));
    if (dom.softScoreBoostCd) appState.softScore.boostCooldownS = Math.max(0, parseInt(dom.softScoreBoostCd.value) || 20);


    // Scalp Indicator Assist (SCALP only)
    if (!appState.scalpInd) appState.scalpInd = { enabled:false };
    if (dom.scalpIndToggle) appState.scalpInd.enabled = !!dom.scalpIndToggle.checked;
    if (dom.scalpIndMode) appState.scalpInd.mode = dom.scalpIndMode.value || "BOOST_ONLY";
    if (dom.scalpIndMa) appState.scalpInd.maPeriod = Math.max(5, parseInt(dom.scalpIndMa.value) || 70);
    if (dom.scalpIndBBPeriod) appState.scalpInd.bbPeriod = Math.max(5, parseInt(dom.scalpIndBBPeriod.value) || 50);
    if (dom.scalpIndBBStd) appState.scalpInd.bbStd = Math.max(0.5, parseFloat(dom.scalpIndBBStd.value) || 2);
    if (dom.scalpIndRSI) appState.scalpInd.rsiPeriod = Math.max(5, parseInt(dom.scalpIndRSI.value) || 14);
    if (dom.scalpIndMacdFast) appState.scalpInd.macdFast = Math.max(2, parseInt(dom.scalpIndMacdFast.value) || 12);
    if (dom.scalpIndMacdSlow) appState.scalpInd.macdSlow = Math.max(5, parseInt(dom.scalpIndMacdSlow.value) || 26);
    if (dom.scalpIndMacdSig) appState.scalpInd.macdSignal = Math.max(2, parseInt(dom.scalpIndMacdSig.value) || 9);
    if (dom.scalpIndBoostMin) appState.scalpInd.boostMinScore = Math.min(100, Math.max(0, parseInt(dom.scalpIndBoostMin.value) || 60));
    if (dom.scalpIndGateMin) appState.scalpInd.gateMinScore = Math.min(100, Math.max(0, parseInt(dom.scalpIndGateMin.value) || 40));
    if (dom.scalpIndHardConf) appState.scalpInd.hardConflictScore = Math.min(100, Math.max(0, parseInt(dom.scalpIndHardConf.value) || 20));

    if (dom.autoTradingToggle) appState.autoTradingEnabled = !!dom.autoTradingToggle.checked;


    // Chart Assist
    if (appState.chartAssist){
      if (dom.chartAssistToggle) appState.chartAssist.enabled = !!dom.chartAssistToggle.checked;
      if (dom.chartAssistMode) appState.chartAssist.mode = dom.chartAssistMode.value || "BOOST";
      if (dom.chartAssistMinCd) appState.chartAssist.minCooldownSec = Math.max(0, parseFloat(dom.chartAssistMinCd.value) || 0);
    }

    if (dom.safeToggle) appState.isSafeMode = !!dom.safeToggle.checked;

    if (dom.priceActionToggle && appState.candleChecks) appState.candleChecks.enabled = !!dom.priceActionToggle.checked;

    // Link bot Safe Mode -> Accumulator Safe Mode when settings are unlocked.
    // This matches the "safe mode auto-detect" request: turning Safe Mode ON
    // automatically turns Accu Safe ON (and OFF turns it off) so ACCU entries stay safer.
    try{
      if (!appState.isSettingsLocked && appState.accu){
        appState.accu.safe = !!appState.isSafeMode;
        if (dom.accuSafe) dom.accuSafe.checked = !!appState.accu.safe;
      }
    }catch(_){}

    // Session limits (extra safety)
    syncSessionLimitsFromUI();


    updateUI();
  } catch(e){
    logLine("UI parse error: " + e.message);
  }
}

/* =========================================================
   Mode defaults
========================================================= */
function loadDefaults(mode){
  const d = modeDefaults[mode];
  if (!d) return;

  appState.mode = mode;
  appState.stakeAmount = d.stake;
  appState.duration = d.duration;
  appState.durationUnit = d.durationUnit;
  appState.tpUSD = d.tp;
  appState.slUSD = d.sl;
  appState.maxTradesPerSignal = d.maxTrades;
  appState.cooldownDuration = d.cooldown;

  appState.tickBufferSize = d.tickBuf;
  appState.momentumThreshold = d.thr;

  appState.useTrendFilter = !!d.trend;
  appState.breakoutStrict = !!d.strict;

  //  Extra guards per mode (safe defaults)
  appState.volGuard.enabled = true;
  appState.candleChecks.enabled = true;
  appState.candleChecks.requireBreakRetest = !!appState.breakoutStrict;
  // Keep optional trade management OFF unless user turns it on manually
  // appState.tradeMgmt.trailingTP / breakEven remain unchanged here

  appState.trend.enabled = appState.useTrendFilter;
  appState.trend.status = appState.trend.enabled ? "LOADING" : "OFF";

  // 
// if we are already connected, refresh H4 trend immediately when switching to MOMENTUM/H4
  appState.trend.lastUpdated = 0;
  if (appState.trend.enabled && appState.isAuthenticated) requestH4Candles();

  updateUI();
}

/* =========================================================
   Chart (Candles with compatibility + fallback)
========================================================= */
let chart=null, series=null, seriesKind="line", ro=null;

function initChart(){
  const container = document.getElementById("chart-container");
  if (!container) return;

  if (typeof LightweightCharts === "undefined"){
    if (dom.chartStatus) setPill(dom.chartStatus, "CHART CDN ERROR", "bg-red-700 text-white");
    logLine("Chart library failed to load.");
    return;
  }

  try{ if (chart && chart.remove) chart.remove(); }catch(_){}

  chart = LightweightCharts.createChart(container, {
    width: container.clientWidth,
    height: container.clientHeight,
    layout: { background: { color:"#0b1220" }, textColor:"#e2e8f0" },
    grid: { vertLines: { color:"#243244" }, horzLines: { color:"#243244" } },
    rightPriceScale: { borderColor:"#334155" },
    timeScale: { borderColor:"#334155", timeVisible:true, secondsVisible:true }
  });

  try{
    if (chart.addCandlestickSeries){
      series = chart.addCandlestickSeries({ priceLineVisible:false, lastValueVisible:true });
      seriesKind = "candles";
      logLine("Chart ready (candles v3/v4).");
    } else if (chart.addSeries && LightweightCharts.CandlestickSeries){
      series = chart.addSeries(LightweightCharts.CandlestickSeries, { priceLineVisible:false, lastValueVisible:true });
      seriesKind = "candles";
      logLine("Chart ready (candles v5).");
    } else {
      throw new Error("Candles not supported");
    }
  } catch(e){
    if (chart.addLineSeries){
      series = chart.addLineSeries({ priceLineVisible:false, lastValueVisible:true });
    } else if (chart.addSeries && LightweightCharts.LineSeries){
      series = chart.addSeries(LightweightCharts.LineSeries, { priceLineVisible:false, lastValueVisible:true });
    }
    seriesKind = "line";
    logLine("Chart fallback → line series (candles unavailable).");
  }

  if (dom.chartStatus) setPill(dom.chartStatus, "READY", "bg-emerald-700 text-white");

  if (ro) ro.disconnect();
  ro = new ResizeObserver(() => {
    try{
      chart.applyOptions({ width: container.clientWidth, height: container.clientHeight });
    }catch(_){}
  });
  ro.observe(container);
  // Accumulator UI
  if (dom.accuToggle && document.activeElement !== dom.accuToggle){
    dom.accuToggle.checked = !!appState.accu?.enabled;
  }
  if (dom.accuSafe && document.activeElement !== dom.accuSafe){
    dom.accuSafe.checked = !!appState.accu?.safe;
  }
  if (dom.accuGrowth && document.activeElement !== dom.accuGrowth){
    dom.accuGrowth.value = String(appState.accu?.growthRate ?? 0.01);
  }
  if (dom.accuTP){
    const tp = appState.accu?.takeProfit;
    setIfNotEditing(dom.accuTP, (tp === null || tp === undefined) ? "" : String(tp));
  }
  if (dom.accuSettings){
    dom.accuSettings.style.display = (appState.accu?.enabled ? "grid" : "none");
  }

}

function updateSeriesFromTick(price){
  if (!series) return;
  const nowSec = Math.floor(Date.now()/1000);

  if (seriesKind === "line"){
    try{ series.update({ time: nowSec, value: price }); }catch(_){}
    return;
  }

  if (nowSec < appState.chart.lastCandleTime) return;

  if (appState.chart.lastCandleTime === 0){
    appState.chart.lastCandleTime = nowSec;
    appState.chart.lastOHLC = { time: nowSec, open: price, high: price, low: price, close: price };
    try{ series.update(appState.chart.lastOHLC); }catch(_){}
    return;
  }

  if (nowSec === appState.chart.lastCandleTime){
    const c = appState.chart.lastOHLC;
    c.high = Math.max(c.high, price);
    c.low  = Math.min(c.low, price);
    c.close = price;
    try{ series.update(c); }catch(_){}
  } else {
    /* 
 PRICE ACTION: finalize previous candle into history */
    if (appState.chart.lastOHLC){
      appState.chart.closedCandles.push({ ...appState.chart.lastOHLC });
      if (appState.chart.closedCandles.length > 240) appState.chart.closedCandles.shift(); // keep last ~4 mins
    }

    appState.chart.lastCandleTime = nowSec;
    appState.chart.lastOHLC = { time: nowSec, open: price, high: price, low: price, close: price };
    try{ series.update(appState.chart.lastOHLC); }catch(_){}
  }
}

/* =========================================================
   Trend EMA
========================================================= */
function calcEMA(values, period){
  if (!values || values.length < period) return null;
  const k = 2/(period+1);
  let ema = values.slice(0,period).reduce((a,b)=>a+b,0)/period;
  for (let i=period;i<values.length;i++) ema = values[i]*k + ema*(1-k);
  return ema;
}
function trendClassify(emaFast, emaSlow){
  if (emaFast == null || emaSlow == null) return "NEUTRAL";
  const diff = emaFast-emaSlow;
  const eps = Math.abs(emaSlow)*0.000001;
  if (diff > eps) return "BULL";
  if (diff < -eps) return "BEAR";
  return "NEUTRAL";
}

/* 
 FIXED: Proper Deriv candles request uses ticks_history + style:"candles"
   Response comes back as msg_type:"history" with history.candles[] */
function requestH4Candles(){
  if (!appState.ws || !appState.isAuthenticated || !appState.trend.enabled) return;

  const req = {
    ticks_history: appState.symbol,
    adjust_start_time: 1,
    count: 80,
    end: "latest",
    style: "candles",
    granularity: appState.trend.tfSeconds
  };

  try{
    appState.ws.send(JSON.stringify(req));
    logLine(`H4 candles requested (history) for ${appState.symbol}`);
  }catch(e){
    appState.trend.status = "ERROR";
    logLine("H4 request send failed: " + e.message);
    updateUI();
  }
}

function maybeRefreshTrend(){
  if (!appState.trend.enabled) return;
  const now = Date.now();
  if (now - appState.trend.lastUpdated < appState.trend.refreshMs) return;
  appState.trend.lastUpdated = now;
  requestH4Candles();
}

function trendAllows(direction){
  if (!appState.trend.enabled) return true;
  if (appState.trend.status === "LOADING") return false;
  if (direction === "CALL") return appState.trend.status === "BULL";
  if (direction === "PUT") return appState.trend.status === "BEAR";
  return false;
}

/* =========================================================
   Signals
========================================================= */
function getMomentumDirection(){
  if (appState.tickBuffer.length < appState.tickBufferSize) return null;
  const first = appState.tickBuffer[0];
  const last  = appState.tickBuffer[appState.tickBuffer.length-1];
  const delta = last-first;
  if (Math.abs(delta) < appState.momentumThreshold) return null;
  return delta > 0 ? "CALL" : "PUT";
}
function passesBreakoutFilter(direction){
  if (!appState.breakoutStrict) return true;
  const buf = appState.tickBuffer;
  if (buf.length < appState.tickBufferSize) return false;
  const last = buf[buf.length-1];
  const hi = Math.max(...buf);
  const lo = Math.min(...buf);
  const span = hi-lo || 1;
  if (direction === "CALL") return (hi-last) <= (span*0.15);
  if (direction === "PUT")  return (last-lo) <= (span*0.15);
  return false;
}

/* =========================================================
   
 PRICE ACTION FILTER (ALL 3 MODES)
   - Uses real 1s candles from chart aggregator
   - Blocks: doji/weak body, wick traps, fake range breakouts
========================================================= */
function paStats(c){
  const range = Math.max(1e-9, c.high - c.low);
  const body = Math.abs(c.close - c.open);
  const upperWick = c.high - Math.max(c.open, c.close);
  const lowerWick = Math.min(c.open, c.close) - c.low;
  return { range, body, upperWick, lowerWick, bodyToRange: body / range };
}

function paRecentRange(candles, n){
  const slice = candles.slice(-n);
  let hi = -Infinity, lo = Infinity;
  for (const c of slice){
    if (c.high > hi) hi = c.high;
    if (c.low < lo) lo = c.low;
  }
  const range = (hi - lo) || 1e-9;
  return { hi, lo, range };
}

// Fake breakout: candle spikes past range but closes back inside
function paIsFakeBreakout(last, rangeHi, rangeLo, direction, buffer){
  if (direction === "CALL"){
    const poked = last.high > (rangeHi + buffer);
    const closedBack = last.close < (rangeHi + buffer*0.25);
    return poked && closedBack;
  } else {
    const poked = last.low < (rangeLo - buffer);
    const closedBack = last.close > (rangeLo - buffer*0.25);
    return poked && closedBack;
  }
}

function passesPriceActionFilter(direction){
  //  Respect Price Action toggle: when OFF, never block trades
  if (appState.candleChecks && appState.candleChecks.enabled === false){
    return true;
  }

  // Need enough closed candles to judge structure
  const candles = appState.chart.closedCandles;
  if (!candles || candles.length < 25) {
    if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "Price Action: Building Candles";
    return false;
  }

  const mode = appState.mode || "SCALP";

  // Mode tuning (SCALP loose, MOMENTUM medium, H4 strict)
  const cfg = {
    SCALP:    { lookback: 20, minBody: 0.38, wickLimit: 0.55, closeEdge: 0.55, bufferFrac: 0.10 },
    MOMENTUM: { lookback: 35, minBody: 0.45, wickLimit: 0.50, closeEdge: 0.60, bufferFrac: 0.12 },
    H4:       { lookback: 50, minBody: 0.52, wickLimit: 0.45, closeEdge: 0.65, bufferFrac: 0.14 }
  }[mode] || { lookback: 20, minBody: 0.38, wickLimit: 0.55, closeEdge: 0.55, bufferFrac: 0.10 };

  const last = candles[candles.length - 1];
  const s = paStats(last);

  // 1) Block doji/weak body
  if (s.bodyToRange < cfg.minBody) {
    if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "Price Action: Weak Candle";
    return false;
  }

  // 2) Block heavy rejection wick against direction
  if (direction === "CALL"){
    if ((s.upperWick / s.range) > cfg.wickLimit){
      if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "Price Action: Wick Trap Up";
      return false;
    }
  } else {
    if ((s.lowerWick / s.range) > cfg.wickLimit){
      if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "Price Action: Wick Trap Down";
      return false;
    }
  }

  // 3) Range context
  const { hi, lo, range } = paRecentRange(candles, cfg.lookback);
  const buffer = range * cfg.bufferFrac;

  // 4) Fake breakout block
  if (paIsFakeBreakout(last, hi, lo, direction, buffer)){
    if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "Price Action: Fake Breakout";
    return false;
  }

  // 5) Close quality: must close near the edge in the direction
  // For CALL -> close should be in upper portion; PUT -> lower portion.
  const closePos = (last.close - lo) / (range || 1e-9); // 0..1
  if (direction === "CALL"){
    if (closePos < cfg.closeEdge){
      if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "Price Action: Weak Close Up";
      return false;
    }
  } else {
    if (closePos > (1 - cfg.closeEdge)){
      if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "Price Action: Weak Close Down";
      return false;
    }
  }

  return true;
}

/* =========================================================
   Clustering detection
========================================================= */
function updateClustering(price){
  const s = String(price);
  const lastChar = s.replace(/\D/g,'').slice(-1) || "0";
  const d = parseInt(lastChar,10);

  appState.lastDigits.push(d);
  while(appState.lastDigits.length > 5) appState.lastDigits.shift();

  if (appState.lastDigits.length < 5) return;

  let sameCount = 0;
  for (let i=1;i<appState.lastDigits.length;i++){
    if (appState.lastDigits[i] === appState.lastDigits[i-1]) sameCount++;
  }

  if (sameCount >= 3){
    dom.clusterAlert?.classList.remove("hidden");
    if (dom.clusterText) dom.clusterText.textContent = `Clustering Detected: ${sameCount} repeats in last 5 ticks → possible reversal/indecision.`;
  } else {
    dom.clusterAlert?.classList.add("hidden");
  }
}

/* =========================================================
   Confidence Meter + Signal
========================================================= */
function computeConfidence(){
  const buf = appState.tickBuffer;
  if (buf.length < appState.tickBufferSize) return { score: 0, signal: "WAIT", notes: "Waiting ticks…" };

  const first = buf[0];
  const last = buf[buf.length-1];
  const delta = last - first;
  const dir = getMomentumDirection();

  const strength = Math.min(1, Math.abs(delta) / Math.max(appState.momentumThreshold, 1e-9));
  let score = Math.round(strength * 60);

  const breakoutOk = passesBreakoutFilter(dir || "CALL");
  if (breakoutOk) score += 15;

  if (appState.trend.enabled){
    if (appState.trend.status === "LOADING") score -= 10;
    else if (dir && trendAllows(dir)) score += 20;
    else score -= 20;
  }

  if (dom.clusterAlert && !dom.clusterAlert.classList.contains("hidden")) score -= 15;

  score = Math.max(0, Math.min(100, score));

  let signal = "WAIT";
  if (dir && score >= 70) signal = (dir === "CALL") ? "BUY" : "SELL";
  else if (dir && score >= 45) signal = "WATCH";

  const notes = `Δ=${delta.toFixed(4)} | Mode=${appState.mode} | Trend=${appState.trend.enabled ? appState.trend.status : "OFF"} | Breakout=${breakoutOk ? "OK" : "WAIT"}`;
  return { score, signal, notes };
}

function updateConfidenceUI(){
  if (!dom.confidenceBar || !dom.confidenceText || !dom.signalPill || !dom.confidenceNotes) return;

  const { score, signal, notes } = computeConfidence();
  dom.confidenceBar.style.width = score + "%";
  dom.confidenceText.textContent = score + "%";
  dom.confidenceNotes.textContent = notes;

  let barCls = "bg-red-500";
  if (score >= 70) barCls = "bg-emerald-500";
  else if (score >= 45) barCls = "bg-yellow-500";
  dom.confidenceBar.className = `h-4 ${barCls}`;

  let pillCls = "bg-slate-700 text-slate-200";
  if (signal === "BUY") pillCls = "bg-emerald-700 text-white";
  if (signal === "SELL") pillCls = "bg-red-700 text-white";
  if (signal === "WATCH") pillCls = "bg-yellow-600 text-white";
  setPill(dom.signalPill, signal, pillCls);
}

/* =========================================================
   Deriv WS + Trading
========================================================= */
function connectToDeriv(){
  try{
    appState.ws = new WebSocket(API_URL);
  }catch(e){
    logLine("WebSocket create failed: " + e.message);
    updateConnection("ERROR", "bg-red-600 text-white");
    return;
  }

  updateConnection("CONNECTING...", "bg-yellow-600 text-white");
  logLine("Connecting to Deriv...");

  appState.ws.onopen = () => {
    logLine("WS open. Authorizing...");
    updateConnection("CONNECTED", "bg-sky-600 text-white");
    appState.ws.send(JSON.stringify({ authorize: appState.token }));
  };

  appState.ws.onclose = () => {
    appState.isAuthenticated = false;
    logLine("WS closed.");
    if (appState.isBotRunning){
      updateConnection("RECONNECTING...", "bg-yellow-600 text-white");
      setTimeout(connectToDeriv, 2500);
    } else {
      updateConnection("DISCONNECTED", "bg-red-800 text-white");
    }
  };

  appState.ws.onerror = () => {
    logLine("WS error (see console).");
    updateConnection("ERROR", "bg-red-600 text-white");
  };

  appState.ws.onmessage = (msg) => {
    let data=null;
    try{ data = JSON.parse(msg.data); }catch(e){
      logLine("Bad JSON received.");
      return;
    }
    handleResponse(data);
  };
}

function stopBot(){
  try{ if (appState.ws) appState.ws.close(); }catch(_){}
  appState.ws = null;

  appState.isBotRunning = false;
  appState.isAuthenticated = false;
  appState.isEntryInProgress = false;
  appState.currentContractId = null;
  appState.isSelling = false;
  appState.tickBuffer = [];
  appState.cooldownUntil = 0;
  appState.pendingProposalId = null;

  appState.currentDirection = null;
  appState.currentSymbolAtEntry = null;

  dom.accountWarning?.classList.add("hidden");

  updateConnection("DISCONNECTED", "bg-red-800 text-white");
  updateTradeStatus("Stopped.", "bg-slate-600 text-slate-300");
  if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "None";

  if (dom.chartStatus) setPill(dom.chartStatus, "WAITING", "bg-slate-700 text-slate-200");
  logLine("Bot stopped.");
  updateUI();
}

function startBot(){
  if (appState.isBotRunning) return;

  const pw = (dom.pwInput?.value || "").trim();
  if (pw !== REQUIRED_PASSWORD){
    dom.pwError?.classList.remove("hidden");
    updateTradeStatus("ACCESS DENIED", "bg-red-600 text-white");
    logLine("Access denied: incorrect password.");
    return;
  }
  dom.pwError?.classList.add("hidden");

  const token = (dom.apiToken?.value || "").trim();
  if (!token){
    dom.tokenError?.classList.remove("hidden");
    updateTradeStatus("ERROR: Enter API Token", "bg-red-600 text-white");
    logLine("Start blocked: missing API token.");
    return;
  }
  dom.tokenError?.classList.add("hidden");

  localStorage.setItem("derivToken", token);
  appState.token = token;

  appState.sessionProfit = 0;
  appState.sessionLoss = 0;
  appState.tradeCounter = 0;
  appState.currentContractId = null;
  appState.isEntryInProgress = false;
  appState.isSelling = false;
  appState.cooldownUntil = 0;
  appState.tickBuffer = [];
  appState.pendingProposalId = null;
  appState.chart.lastCandleTime = 0;
  appState.chart.lastOHLC = null;
  appState.chart.hasTick = false;
  appState.lastDigits = [];

  // 
// PRICE ACTION: reset candle history on start
  appState.chart.closedCandles = [];

  appState.currentDirection = null;
  appState.currentSymbolAtEntry = null;

  dom.accountWarning?.classList.add("hidden");

  updateProfit(appState.sessionProfit);
  updateLoss(appState.sessionLoss);

  appState.isBotRunning = true;
  logLine("Bot started.");
  updateUI();
  connectToDeriv();
}

function subscribeTicks(symbol){
  if (!appState.ws || !appState.isAuthenticated) return;
  try{
    appState.ws.send(JSON.stringify({ forget_all: "ticks" }));
  }catch(_){}
  appState.ws.send(JSON.stringify({ ticks: symbol, subscribe: 1 }));
  logLine("Subscribing ticks: " + symbol);
}

function handleResponse(res){
  if (res.error){
    const msg = res.error.message || "Unknown API error";
    logLine("API Error: " + msg);

    // If trend request fails, don't leave it stuck on LOADING forever
    if (appState.trend.enabled && msg.toLowerCase().includes("unrecognised request")){
      appState.trend.status = "ERROR";
      logLine("H4 Trend failed: wrong request. (Now fixed in this version)");
      updateUI();
    }

    const m = msg.toLowerCase();
    if (m.includes("symbol") || m.includes("market") || m.includes("available") || m.includes("not found")){
      dom.accountWarning?.classList.remove("hidden");
      if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "Symbol not available on this account";
      updateTradeStatus("SYMBOL ERROR", "bg-red-600 text-white");
    }

    if (res.error.code === "AuthorizationRequired"){
      if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "Auth Failed";
      stopBot();
    }
    return;
  }

  switch(res.msg_type){

    case "authorize":{
      appState.isAuthenticated = true;
      const bal = Number(res.authorize.balance || 0);
      appState.currentBalance = bal;
      appState.isDemo = !!res.authorize.is_virtual;

      if (dom.balanceDisplay){
        dom.balanceDisplay.textContent = `${res.authorize.currency || "USD"} ${bal.toFixed(2)}`;
      }

      logLine("Authorized. Account=" + (appState.isDemo ? "DEMO" : "REAL"));

      subscribeTicks(appState.symbol);
      appState.ws.send(JSON.stringify({ balance: 1, subscribe: 1 }));
      appState.ws.send(JSON.stringify({ proposal_open_contract: 1, subscribe: 1 }));

      // Load extra markets (e.g., BTC/USD) dynamically, if available on this account
      requestActiveSymbols();

      appState.trend.lastUpdated = 0;
      if (appState.trend.enabled){
        appState.trend.status = "LOADING";
        requestH4Candles(); // 
// now correct request
      } else {
        appState.trend.status = "OFF";
      }

      updateTradeStatus("Monitoring Ticks...", "bg-yellow-600 text-white");
      if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "None";
      if (dom.chartStatus) setPill(dom.chartStatus, "LIVE", "bg-sky-700 text-white");

      updateUI();
      break;
    }

    case "balance":{
      const bal = Number(res.balance.balance || 0);
      appState.currentBalance = bal;
      if (dom.balanceDisplay){
        dom.balanceDisplay.textContent = `${res.balance.currency || "USD"} ${bal.toFixed(2)}`;
      }
      break;
    }


    case "active_symbols":{
      // Populate USD-quoted instruments into the Market selector (BTC/USD etc.)
      appendUsdQuoteSymbolsToSelect(res.active_symbols || []);
      break;
    }

    case "tick":{
      if (!appState.isBotRunning) return;

      const price = Number(res.tick.quote);
      if (!Number.isFinite(price)) return;

      updateSeriesFromTick(price);
      updateClustering(price);

      // Chart Assist scan (optional)
      if (appState.chartAssist?.enabled) {
        try{ chartAssist.onTick(price); }catch(_){ }
      }

      appState.lastTick = price;

      // AI live feed (safety-only)
      aiLayer.onPriceTick(price, Date.now());
      // Burst Protection (optional)
      try{ burstProtect.onTick(price, Date.now()); }catch(_){ }
      appState.tickBuffer.push(price);
      while(appState.tickBuffer.length > appState.tickBufferSize) appState.tickBuffer.shift();

      maybeRefreshTrend();

      if (appState.autoTradingEnabled) checkAndEnterTrade();

      updateUI();
      break;
    }

    /* 
 FIXED: H4 candles now arrive as msg_type:"history" */
    case "history":{
      // H4 trend + optional HTF confirm both use msg_type:"history"
      if (!appState.trend.enabled && !appState.htfConfirm?.enabled) return;

      const candles = res.history?.candles;
      if (!candles || !Array.isArray(candles) || candles.length < 10){
        appState.trend.status = "ERROR";
        logLine("H4 Trend history error (no candles).");
        updateUI();
        return;
      }

      const closes = candles
        .map(c => parseFloat(c.close))
        .filter(n => Number.isFinite(n));

      const ema20 = calcEMA(closes, appState.trend.emaFast);
      const ema50 = calcEMA(closes, appState.trend.emaSlow);

      appState.trend.status = trendClassify(ema20, ema50);
      _updateHTFTrendFromHistory(res);

      logLine(`H4 Trend updated: ${appState.trend.status}`);
      updateUI();
      break;
    }

    /* (Optional backwards compatibility if any environment still returns "candles") */
    case "candles":{
      if (!res.candles || !Array.isArray(res.candles)){
        appState.trend.status = "ERROR";
        logLine("Trend candles error.");
        updateUI();
        return;
      }
      const closes = res.candles.map(c => parseFloat(c.close)).filter(n => Number.isFinite(n));
      const ema20 = calcEMA(closes, appState.trend.emaFast);
      const ema50 = calcEMA(closes, appState.trend.emaSlow);
      appState.trend.status = trendClassify(ema20, ema50);
      updateUI();
      break;
    }

    case "proposal":{
      if (!appState.isEntryInProgress) return;
      if (!res.proposal?.id){
        appState.isEntryInProgress = false;
        logLine("Proposal missing ID.");
        return;
      }
      appState.pendingProposalId = res.proposal.id;

      // AI FINAL safety gate (right before BUY)
      const ctx = {
        stage: "BEFORE_BUY",
        direction: appState.currentDirection,
        stake: appState.stakeAmount,
        symbol: appState.symbol,
        mode: appState.mode,
        accuEnabled: !!(appState.accu && appState.accu.enabled),
        tickBuffer: appState.tickBuffer,
        closedCandles: appState.chart?.closedCandles || [],
        sessionProfit: appState.sessionProfit,
        sessionLoss: appState.sessionLoss,
        cooldownUntil: appState.cooldownUntil,
        aiCooldownUntil: aiLayer.cooldownExtraUntil,
        now: Date.now()
      };
      const decision = aiLayer.shouldAllowTrade(ctx);
      if (!decision.allow) {
        // Cancel entry cleanly (do NOT buy)
        appState.isEntryInProgress = false;
        appState.pendingProposalId = null;

        aiLayer.lastBlockReason = decision.reason || "AI blocked (before buy)";
        if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = aiLayer.lastBlockReason;
        updateTradeStatus("BLOCKED (AI)", "bg-slate-700 text-slate-200");
        logLine("[AI] Blocked before BUY: " + aiLayer.lastBlockReason);

        if (decision.cooldownMs) {
          aiLayer.cooldownExtraUntil = Math.max(aiLayer.cooldownExtraUntil, Date.now() + decision.cooldownMs);
        }
        updateAIGuardUI();
        return; // IMPORTANT: exits the case without buying
      }
      if (decision.cooldownMs) {
        aiLayer.cooldownExtraUntil = Math.max(aiLayer.cooldownExtraUntil, Date.now() + decision.cooldownMs);
      }

      // FINAL BUY (unchanged core flow)
      appState.ws.send(JSON.stringify({ buy: appState.pendingProposalId, price: appState.stakeAmount }));

      break;
    }

    case "buy":{
      appState.isEntryInProgress = false;
      appState.pendingProposalId = null;
      appState.currentContractId = res.buy.contract_id;
      initTradeMgmtForNewContract();
      updateTradeStatus("Contract Active", "bg-indigo-600 text-white");
      logLine("Bought contract: " + appState.currentContractId);
      break;
    }

    case "proposal_open_contract":{
      const c = res.proposal_open_contract;
      if (!c) return;

      setSellable(c.is_sellable);

      if (appState.currentContractId && c.contract_id === appState.currentContractId){
        if (c.is_sold === 1){
          const profit = Number(c.sell_price) - Number(c.buy_price);

          appState.sessionProfit += profit;
          if (profit < 0) appState.sessionLoss += Math.abs(profit);

          updateProfit(appState.sessionProfit);
          updateLoss(appState.sessionLoss);

          // Session limits counters (extra safety)
          appState.sessionTrades += 1;
          if (profit > 0) appState.sessionWins += 1;
          else if (profit < 0) appState.sessionLosses += 1;
          renderSessionLimitsUI();
          // Stop bot if any session limit is hit
          checkSessionLimitsAndMaybeStop();


          const sym = appState.currentSymbolAtEntry || appState.symbol || "UNKNOWN";
          const dir = appState.currentDirection || "UNKNOWN";
          const pnl = (profit >= 0 ? "+" : "") + profit.toFixed(2);
          txLogLine(`CLOSED | ${sym} | ${dir} | ${pnl}`);

          appState.currentContractId = null;
          appState.isSelling = false;
          appState.tickBuffer = [];
          appState.tradeCounter = 0;

          appState.currentDirection = null;
          appState.currentSymbolAtEntry = null;

          appState.cooldownUntil = Date.now() + (appState.cooldownDuration * 1000);
          if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "Cooldown";
          updateTradeStatus("Trade Closed. Cooldown...", "bg-orange-500 text-white");
          logLine("Trade closed. P/L: " + profit.toFixed(2));
addTransactionEntry({
  market: appState.currentSymbol || "UNKNOWN",
  payout: profit,
  duration: appState.lastTradeDuration || null,
  status: profit > 0 ? "WON" : "LOST",
  system: "MillzAI"
});


          // AI trade outcome feed (safety-only)
          aiLayer.onTradeClosed(profit, Date.now());

          if (appState.autoResume){
            setTimeout(() => {
              if (!appState.isBotRunning) return;
              if (Date.now() >= appState.cooldownUntil){
                if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "None";
                updateTradeStatus("Monitoring Ticks...", "bg-yellow-600 text-white");
              }
            }, appState.cooldownDuration * 1000);
          }
        } else {
          checkProfitAndLoss(c);
        }
      }
      updateUI();
      break;
    }
  }
}

/* =========================================================
   Entry + TP/SL
========================================================= */
function checkAndEnterTrade(){
  if (!appState.isBotRunning || !appState.isAuthenticated) return;

  // refresh HTF confirmation candles (optional)
  requestHTFCandles();

  // Respect bot cooldown + AI cooldown
  let effectiveCooldownUntil = Math.max(appState.cooldownUntil || 0, aiLayer.cooldownExtraUntil || 0, appState.burstCooldownUntil || 0, appState.softScoreCooldownUntil || 0);

  if (Date.now() < effectiveCooldownUntil){
    // Chart Assist can shorten ONLY the bot cooldown when it sees a strong quick setup
    if ((appState.chartAssist?.enabled && appState.chartAssist.mode === "BOOST") || (appState.scalpInd?.enabled && (appState.scalpInd.mode||"BOOST_ONLY")==="BOOST_ONLY" && appState.mode==="SCALP")){
      const dirPeek = getMomentumDirection();
      if (dirPeek){
        try{ chartAssist.maybeBoostCooldown(dirPeek, effectiveCooldownUntil); }catch(_){}
      }
      effectiveCooldownUntil = Math.max(appState.cooldownUntil || 0, aiLayer.cooldownExtraUntil || 0, appState.burstCooldownUntil || 0, appState.softScoreCooldownUntil || 0);
    }

    if (Date.now() < effectiveCooldownUntil){
      if (dom.blockReasonDisplay){
        dom.blockReasonDisplay.textContent =
          (Date.now() < (appState.burstCooldownUntil||0)) ? "Burst Cooldown" :
          (Date.now() < (appState.softScoreCooldownUntil||0)) ? "Soft Score Cooldown" :
          (Date.now() < (aiLayer.cooldownExtraUntil||0)) ? "AI Cooldown" :
          "Cooldown";
      }
      return;
    }
  }
  if (appState.isEntryInProgress){
    if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "Entry In Progress";
    return;
  }
  if (appState.currentContractId){
    if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "Trade Active";
    return;
  }
  if (appState.tradeCounter >= appState.maxTradesPerSignal){
    if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "Max Trades/Signal Hit";
    return;
  }

  const direction = getMomentumDirection();
  if (!direction){
    if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "Waiting Good Move";
    return;
  }
  if (!passesBreakoutFilter(direction)){
    if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "Waiting Breakout";
    return;
  }

  if (appState.trend.enabled){
    if (appState.trend.status === "LOADING"){
      if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "H4 Trend Loading";
      return;
    }
    if (!trendAllows(direction)){
      if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = `H4 Trend Blocked (${appState.trend.status})`;
      return;
    }
  }

  /* 
 PRICE ACTION GATE (AUTO) */
  if (!passesPriceActionFilter(direction)){
    // block reason already set inside the filter
    return;
  }

  /*  VOLATILITY GUARD (AUTO) */
  if (!passesVolatilityGuard()){
    return;
  }

  /*  CANDLE STRUCTURE CHECKS (AUTO) */
  if (!passesCandleStructure(direction)){
    return;
  }

  /*  HTF CONFIRM (OPTIONAL) */
  if (appState.htfConfirm?.enabled){
    if (appState.htfConfirm.status === "OFF") requestHTFCandles();
    if (!htfAllows(direction)){
      if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = `HTF Blocked (${appState.htfConfirm.status})`;
      return;
    }
  }

  if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "None";
  // Chart Assist gate (optional)
  if ((appState.chartAssist?.enabled && appState.chartAssist.mode === "GATE") || (appState.scalpInd?.enabled && (appState.scalpInd.mode||"BOOST_ONLY")==="GATE" && appState.mode==="SCALP")){
    const g = chartAssist.shouldGate(direction);
    if (!g.allow){
      if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = g.reason || "Chart Assist blocked";
      return;
    }
  }


  // Soft Score (optional) - gentle quality control
  if (appState.softScore?.enabled){
    const ss = computeSoftScore(direction);
    const blockBelow = Math.max(0, Math.min(100, Number(appState.softScore.blockBelow ?? 45)));
    const boostBelow = Math.max(0, Math.min(100, Number(appState.softScore.boostBelow ?? 60)));
    const boostCdS = Math.max(0, Number(appState.softScore.boostCooldownS ?? 20));

    if (ss.score < blockBelow){
      const msg = `Soft Score Block (${ss.score})`;
      if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = msg;
      updateTradeStatus("BLOCKED (Soft Score)", "bg-slate-700 text-slate-200");
      logLine("[SoftScore] Blocked: " + msg + " [" + (ss.reasons||[]).join(",") + "]");
      return;
    }
    if (ss.score < boostBelow && boostCdS > 0){
      appState.softScoreCooldownUntil = Math.max(appState.softScoreCooldownUntil || 0, Date.now() + boostCdS * 1000);
      const msg = `Soft Score Cooldown (${ss.score})`;
      if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = msg;
      updateTradeStatus("Stand down...", "bg-orange-500 text-white");
      return;
    }
  }

  const stake = getEffectiveStake();
  enterTrade(direction, stake);
}

function enterTrade(direction, stake){
  if (!appState.ws || !appState.isAuthenticated) return;


  // AI safety gate (does NOT change strategy)
  const ctx = {
    stage: "ENTER_TRADE",
    direction,
    stake,
    symbol: appState.symbol,
    mode: appState.mode,
    accuEnabled: !!(appState.accu && appState.accu.enabled),
    tickBuffer: appState.tickBuffer,
    closedCandles: appState.chart?.closedCandles || [],
    sessionProfit: appState.sessionProfit,
    sessionLoss: appState.sessionLoss,
    cooldownUntil: appState.cooldownUntil,
    aiCooldownUntil: aiLayer.cooldownExtraUntil,
    now: Date.now()
  };
  const decision = aiLayer.shouldAllowTrade(ctx);
  if (!decision.allow) {
    aiLayer.lastBlockReason = decision.reason || "AI blocked (enterTrade)";
    if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = aiLayer.lastBlockReason;
    updateTradeStatus("BLOCKED (AI)", "bg-slate-700 text-slate-200");
    logLine("[AI] Blocked before proposal: " + aiLayer.lastBlockReason);
    updateAIGuardUI();
    return; // IMPORTANT: do not continue into proposal request
  }
  if (decision.cooldownMs) {
    aiLayer.cooldownExtraUntil = Math.max(aiLayer.cooldownExtraUntil, Date.now() + decision.cooldownMs);
  }

  appState.currentDirection = (appState.accu && appState.accu.enabled) ? 'ACCU' : direction;
  appState.currentSymbolAtEntry = appState.symbol;

  appState.isEntryInProgress = true;
  appState.pendingProposalId = null;
  appState.tickBuffer = [];
  updateTradeStatus((appState.accu && appState.accu.enabled) ? "Creating Proposal (ACCU)..." : `Creating Proposal (${direction})...`, "bg-orange-500 text-white");

  // Build proposal request (ACCU uses growth_rate + optional limit_order.take_profit)
  let req;
  if (appState.accu && appState.accu.enabled){
    // Safe Mode: cap growth to 12%
    const safe = !!appState.accu.safe;
    const growth = Math.max(0.01, Math.min(0.05, Number(appState.accu.growthRate || 0.01)));
    const growthRate = safe ? Math.min(growth, 0.02) : growth;

    req = {
      proposal: 1,
      amount: stake,
      basis: "stake",
      contract_type: "ACCU",
      currency: "USD",
      symbol: appState.symbol,
      growth_rate: growthRate
    };

    // Server-side auto sell by profit target (TP)
    const tp = Number(appState.accu.takeProfit);
    if (Number.isFinite(tp) && tp > 0){
      req.limit_order = { take_profit: tp };
    }
  } else {
    req = {
      proposal: 1,
      amount: stake,
      basis: "stake",
      contract_type: direction,
      currency: "USD",
      duration: appState.duration,
      duration_unit: appState.durationUnit,
      symbol: appState.symbol
    };
  }

  appState.ws.send(JSON.stringify(req));

  setTimeout(() => {
    if (!appState.isBotRunning) return;
    if (appState.currentContractId) return;
    if (appState.isEntryInProgress){
      appState.isEntryInProgress = false;
      updateTradeStatus("Monitoring Ticks...", "bg-yellow-600 text-white");
      if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "Entry Timeout";
      logLine("Entry timeout. Reset.");
    }
  }, 10000);

  appState.tradeCounter++;
}

function checkProfitAndLoss(contract){
  const currentProfit = Number(contract.profit);

  if (!appState.autoSellEnabled) return;

  //  Optional trade management (non-invasive). If it triggers, it sells and returns.
  if (appState.currentContractId){
    if (applyTradeManagement(currentProfit, contract)) return;
  }

  // Default TP behavior (unchanged)
  if (currentProfit >= appState.tpUSD){
    sellContract();
    return;
  }

  // Default SL behavior in Safe Mode (unchanged)
  if (appState.isSafeMode){
    const lossThreshold = -Math.abs(appState.slUSD);
    if (currentProfit <= lossThreshold){
      sellContract();
    }
  }
}

function sellContract(){
  if (appState.isSelling) return;
  if (!appState.currentContractId) return;

  if (appState.is_sellable !== 1){
    if (dom.blockReasonDisplay) dom.blockReasonDisplay.textContent = "Not Sellable";
    return;
  }

  appState.isSelling = true;
  updateTradeStatus("Selling...", "bg-red-500 text-white");
  appState.ws.send(JSON.stringify({ sell: appState.currentContractId, price: 0 }));
  logLine("Sell requested.");
}

/* =========================================================
   Insights (fallback)
========================================================= */
function fallbackInsight(type){
  const trend = appState.trend.enabled ? appState.trend.status : "OFF";
  const dir = getMomentumDirection() || "NONE";
  const buf = appState.tickBuffer;
  const first = buf.length ? buf[0] : null;
  const last  = buf.length ? buf[buf.length-1] : null;
  const delta = (first!=null && last!=null) ? (last-first) : 0;

  if (type === "sentiment"){
    const conf = computeConfidence();
    return [
      `Safe Entry Suggestion (Fallback):`,
      `• Symbol: ${appState.symbol}`,
      `• Mode: ${appState.mode}`,
      `• Trend Filter: ${trend}`,
      `• Momentum: ${dir} | Δ=${delta.toFixed(4)}`,
      `• Breakout Strict: ${appState.breakoutStrict ? "ON" : "OFF"}`,
      `• Confidence: ${conf.score}% | Signal: ${conf.signal}`,
      ``,
      `Suggested Action:`,
      conf.signal === "BUY" ? "• BUY setup is strong (conditions passing)" :
      conf.signal === "SELL" ? "• SELL setup is strong (conditions passing)" :
      conf.signal === "WATCH" ? "• WATCH (signal forming, wait cleaner move)" :
      "• WAIT (not enough confirmation)",
      ``,
      `Risk Level: MEDIUM (synthetics move fast — keep stake small).`
    ].join("\n");
  }

  return [
    `Risk Check (Fallback):`,
    `• Stake: $${appState.stakeAmount.toFixed(2)}`,
    `• TP: $${appState.tpUSD.toFixed(2)} | SL: $${appState.slUSD.toFixed(2)} (SL sells only if Safe Mode ON)`,
    `• Duration: ${appState.duration} ${appState.durationUnit}`,
    `• Cooldown: ${appState.cooldownDuration}s`,
    `• Auto Trading: ${appState.autoTradingEnabled ? "ON" : "OFF"}`,
    `• Session P/L: $${appState.sessionProfit.toFixed(2)} | Loss: $${appState.sessionLoss.toFixed(2)}`
  ].join("\n");
}

async function showInsight(type){
  if (!dom.geminiOut) return;
  dom.geminiLoading?.classList.remove("hidden");
  dom.geminiOut.textContent = "Analyzing...";
  await new Promise(r => setTimeout(r, 350));
  dom.geminiOut.textContent = fallbackInsight(type);
  dom.geminiLoading?.classList.add("hidden");
}

/* =========================================================
   Token helpers
========================================================= */
function toggleTokenVisibility(){
  if (!dom.apiToken) return;
  dom.apiToken.type = (dom.apiToken.type === "password") ? "text" : "password";
}
function copyApiUrl(){
  const t = dom.apiUrlText?.textContent || "";
  navigator.clipboard?.writeText(t).then(() => logLine("API URL copied."), () => logLine("Copy failed."));
}

/* =========================================================
   Manual controls
========================================================= */
function manualPlaceTrade(mult=1){
  if (!appState.isAuthenticated){
    logLine("Manual trade blocked: not connected.");
    updateTradeStatus("Connect first.", "bg-red-600 text-white");
    return;
  }
  if (appState.currentContractId || appState.isEntryInProgress){
    logLine("Manual trade blocked: trade already active.");
    return;
  }

  const conf = computeConfidence();
  const dir = getMomentumDirection();

  if (!dir){
    updateTradeStatus("WAIT: no signal", "bg-yellow-600 text-white");
    logLine("Manual trade: no momentum signal yet.");
    return;
  }
  if (appState.trend.enabled && !trendAllows(dir)){
    updateTradeStatus("AVOID: trend mismatch", "bg-yellow-600 text-white");
    logLine("Manual trade blocked: trend mismatch.");
    return;
  }
  if (!passesBreakoutFilter(dir)){
    updateTradeStatus("WAIT: breakout not clean", "bg-yellow-600 text-white");
    logLine("Manual trade: breakout not clean.");
    return;
  }

  /* 
 PRICE ACTION GATE (MANUAL) */
  if (!passesPriceActionFilter(dir)){
    updateTradeStatus("WAIT: price action", "bg-yellow-600 text-white");
    return;
  }

  if (conf.score < 45){
    updateTradeStatus("WATCH: confidence low", "bg-yellow-600 text-white");
    logLine("Manual trade blocked: confidence below 45%.");
    return;
  }

  enterTrade(dir, appState.stakeAmount * mult);
}

function clearHistory(){
  appState.sessionProfit = 0;
  appState.sessionLoss = 0;
  updateProfit(appState.sessionProfit);
  updateLoss(appState.sessionLoss);

  if (TXLOG) TXLOG.textContent = "";

  logLine("History cleared (session profit/loss reset).");
  txLogLine("CLEARED | Transaction log reset");
}

/* =========================================================
   Symbol switching
========================================================= */
// =========================
// Dynamic symbol list (adds BTC/USD + other USD quote instruments when available)
// Uses Deriv 'active_symbols' to avoid hardcoding symbol names.
// Request: { active_symbols: "brief", product_type: "basic" }  (see Deriv docs)
// =========================
function requestActiveSymbols(){
  if (!appState.ws) return;
  try{
    appState.ws.send(JSON.stringify({ active_symbols: "brief", product_type: "basic" }));
  }catch(e){
    logLine("active_symbols request failed: " + e.message);
  }
}

function appendUsdQuoteSymbolsToSelect(activeList){
  if (!dom.symbolSelect || !Array.isArray(activeList)) return;

  // Build a set of existing option values to avoid duplicates
  const existing = new Set(Array.from(dom.symbolSelect.options || []).map(o => o.value));

  // Filter: only USD-quoted instruments (Forex, Crypto, etc.)
  const usd = activeList
    .filter(s => (s && typeof s === "object"))
    .filter(s => {
      const dn = String(s.display_name || "");
      const qc = String(s.quote_currency || "");
      // Prefer explicit quote_currency when provided; otherwise fall back to display_name matching
      return qc === "USD" || /\bUSD\b/.test(dn);
    });

  // Sort: crypto first (BTC, ETH), then alphabetical
  usd.sort((a,b) => {
    const aName = String(a.display_name || a.symbol || "");
    const bName = String(b.display_name || b.symbol || "");
    const aIsBTC = /BTC/i.test(aName);
    const bIsBTC = /BTC/i.test(bName);
    if (aIsBTC && !bIsBTC) return -1;
    if (!aIsBTC && bIsBTC) return 1;
    return aName.localeCompare(bName);
  });

  // Create a disabled separator once
  const sepValue = "__USD_SEPARATOR__";
  if (!existing.has(sepValue) && usd.length){
    const sep = document.createElement("option");
    sep.value = sepValue;
    sep.disabled = true;
    sep.textContent = "¢¢¢¢¢¢¢¢ USD Markets (Auto) ¢¢¢¢¢¢¢¢";
    dom.symbolSelect.appendChild(sep);
    existing.add(sepValue);
  }

  // Append instruments
  let added = 0;
  for (const s of usd){
    const symbol = String(s.symbol || "").trim();
    if (!symbol) continue;
    if (existing.has(symbol)) continue;

    const label = String(s.display_name || symbol);
    const opt = document.createElement("option");
    opt.value = symbol;
    opt.textContent = `${label} (${symbol})`;
    dom.symbolSelect.appendChild(opt);
    existing.add(symbol);
    added++;
  }

  if (added){
    logLine(`Added ${added} USD market(s) from active_symbols (incl. crypto/forex if your account allows).`);
  }
}

function setSymbol(newSymbol){
  newSymbol = (newSymbol || "").trim();
  if (!newSymbol) return;

  dom.accountWarning?.classList.add("hidden");

  appState.symbol = newSymbol;
  if (dom.currentSymbolLabel) dom.currentSymbolLabel.textContent = newSymbol;

  appState.tickBuffer = [];
  appState.lastDigits = [];
  appState.chart.lastCandleTime = 0;
  appState.chart.lastOHLC = null;

  // 
// PRICE ACTION: reset candle history on symbol switch
  appState.chart.closedCandles = [];

  appState.trend.lastUpdated = 0;
  if (appState.trend.enabled) appState.trend.status = "LOADING";

  if (appState.isAuthenticated){
    subscribeTicks(newSymbol);

    // 
// refresh trend candles for the NEW symbol
    if (appState.trend.enabled) requestH4Candles();

    logLine("Symbol switched to: " + newSymbol);
  } else {
    logLine("Symbol set (will subscribe after connect): " + newSymbol);
  }
  updateUI();
}

/* =========================================================
   INIT
========================================================= */
document.addEventListener("DOMContentLoaded", () => {
  try{
    // =========================
    // Continue normal app init
    // =========================
    initChart();

    loadDefaults(appState.mode);
    setSettingsLock(true);

    // =========================
    // UI wiring (Unlock + ACCU)
    // =========================
    if (dom.unlockBtn){
      dom.unlockBtn.addEventListener("click", (e) => {
        e.preventDefault();
        setSettingsLock(!appState.isSettingsLocked);
        updateUI();
        logLine(`Settings ${appState.isSettingsLocked ? "LOCKED" : "UNLOCKED"}`);
      }, { passive:false });
    }

    // Accumulator master toggle
    if (dom.accuToggle){
      dom.accuToggle.addEventListener("change", () => {
        appState.accu.enabled = !!dom.accuToggle.checked;
        updateUI();
        logLine(`Accumulator: ${appState.accu.enabled ? "ON" : "OFF"}`);
      });
    }

    // Accumulator Safe Mode
    if (dom.accuSafe){
      dom.accuSafe.addEventListener("change", () => {
        appState.accu.safe = !!dom.accuSafe.checked;
        updateUI();
      });
    }

    // Growth rate selector (dropdown)
    if (dom.accuGrowth){
      dom.accuGrowth.addEventListener("change", () => {
        const v = Number(dom.accuGrowth.value);
        if (Number.isFinite(v) && v > 0){
          appState.accu.growthRate = v;
          updateUI();
          logLine(`ACCU Growth: ${(v*100).toFixed(0)}%`);
        }
      });
    }

    // Growth rate quick buttons (1%..5%)
    document.querySelectorAll("[data-accu-growth]").forEach(btn => {
      btn.addEventListener("click", () => {
        const v = Number(btn.getAttribute("data-accu-growth"));
        if (Number.isFinite(v) && v > 0){
          appState.accu.growthRate = v;
          if (dom.accuGrowth) dom.accuGrowth.value = String(v);
          updateUI();
          logLine(`ACCU Growth: ${(v*100).toFixed(0)}%`);
        }
      });
    });

    // Optional Auto-sell TP for ACCU (leave empty for no TP)
    if (dom.accuTP){
      dom.accuTP.addEventListener("change", () => {
        const raw = String(dom.accuTP.value || "").trim();
        const v = raw === "" ? null : Number(raw);
        appState.accu.takeProfit = (v === null || !Number.isFinite(v) || v <= 0) ? null : v;
        updateUI();
      });
    }

    // Session limits init
    if (dom.sessLimitEnabled){
      dom.sessLimitEnabled.checked = !!appState.sessLimitsEnabled;
    }
    if (dom.sessLimitReset){
      dom.sessLimitReset.addEventListener("click", () => {
        resetSessionLimits();
        logLine("Session limits counters reset.");
      });
    }
    renderSessionLimitsUI();



    // AI Guard toggle (safety-only)
    if (dom.aiGuardToggle){
      dom.aiGuardToggle.checked = !!aiLayer.enabled;
      dom.aiGuardToggle.addEventListener("change", (e) => {
        aiLayer.enabled = !!e.target.checked;
        aiLayer.lastBlockReason = aiLayer.enabled ? "None" : "AI Guard OFF";
        logLine("[AI] Guard " + (aiLayer.enabled ? "ENABLED" : "DISABLED"));
        updateAIGuardUI();
      });
    }
    updateAIGuardUI();

    if (appState.token && dom.apiToken){
      dom.apiToken.value = appState.token;
      if (dom.editHint) dom.editHint.textContent = "Token loaded and saved. Type password then click START BOT to connect.";
    }

    if (dom.pwInput) dom.pwInput.value = "";

    if (dom.symbolSelect) dom.symbolSelect.value = appState.symbol;

    document.querySelectorAll("input, select").forEach(el => {
      // IMPORTANT: Accumulator controls have their own handlers. If we bind the generic
      // updateStateFromUI first, iOS/Safari will "snap back" the toggle before our
      // accumulator handler runs. So we skip them here.
      const skipIds = new Set(["accu-toggle","accu-safe","accu-growth","accu-tp"]);
      if (el && el.id && skipIds.has(el.id)) return;

      el.addEventListener("input", updateStateFromUI);
      el.addEventListener("change", updateStateFromUI);
    });

    dom.toggleBotBtn?.addEventListener("click", () => {
      if (!appState.isBotRunning){
        const token = (dom.apiToken?.value || "").trim();
        if (!token){
          dom.tokenError?.classList.remove("hidden");
          return;
        } else dom.tokenError?.classList.add("hidden");
      }

      if (appState.isBotRunning) stopBot();
      else startBot();
    });
    dom.modeSelect?.addEventListener("change", (e) => loadDefaults(e.target.value));

    dom.safeToggle?.addEventListener("change", () => updateStateFromUI());
    dom.autoResumeToggle?.addEventListener("change", () => updateStateFromUI());
    dom.autoSellToggle?.addEventListener("change", () => updateStateFromUI());
    dom.smartTakeoutToggle?.addEventListener("change", () => updateStateFromUI());
    dom.smartTakeoutPrimary?.addEventListener("input", () => updateStateFromUI());
    dom.smartTakeoutFallback?.addEventListener("input", () => updateStateFromUI());
    dom.smartTakeoutFallbackPct?.addEventListener("input", () => updateStateFromUI());
    dom.smartTakeoutStallTicks?.addEventListener("input", () => updateStateFromUI());

    // Tick Ladder
    dom.tickLadderToggle?.addEventListener("change", () => { updateStateFromUI(); updateUI(); });
    dom.tickLadderStart?.addEventListener("input", () => updateStateFromUI());
    dom.tickLadderMid?.addEventListener("input", () => updateStateFromUI());
    dom.tickLadderMax?.addEventListener("input", () => updateStateFromUI());
    dom.tickLadderWindow?.addEventListener("input", () => updateStateFromUI());
    dom.tickLadderDTouch?.addEventListener("input", () => updateStateFromUI());

    // Burst Protection + Soft Score
    dom.burstProtectToggle?.addEventListener("change", () => { updateStateFromUI(); updateUI(); });
    dom.burstProtectLookback?.addEventListener("input", () => updateStateFromUI());
    dom.burstProtectMult?.addEventListener("input", () => updateStateFromUI());
    dom.burstProtectMinCd?.addEventListener("input", () => updateStateFromUI());
    dom.burstProtectMaxCd?.addEventListener("input", () => updateStateFromUI());

    dom.softScoreToggle?.addEventListener("change", () => { updateStateFromUI(); updateUI(); });
    dom.softScoreBlock?.addEventListener("input", () => updateStateFromUI());
    dom.softScoreBoost?.addEventListener("input", () => updateStateFromUI());
    dom.softScoreBoostCd?.addEventListener("input", () => updateStateFromUI());


    dom.scalpIndToggle?.addEventListener("change", () => { updateStateFromUI(); updateUI(); });
    dom.scalpIndMode?.addEventListener("change", () => updateStateFromUI());
    dom.scalpIndMa?.addEventListener("input", () => updateStateFromUI());
    dom.scalpIndBBPeriod?.addEventListener("input", () => updateStateFromUI());
    dom.scalpIndBBStd?.addEventListener("input", () => updateStateFromUI());
    dom.scalpIndRSI?.addEventListener("input", () => updateStateFromUI());
    dom.scalpIndMacdFast?.addEventListener("input", () => updateStateFromUI());
    dom.scalpIndMacdSlow?.addEventListener("input", () => updateStateFromUI());
    dom.scalpIndMacdSig?.addEventListener("input", () => updateStateFromUI());
    dom.scalpIndBoostMin?.addEventListener("input", () => updateStateFromUI());
    dom.scalpIndGateMin?.addEventListener("input", () => updateStateFromUI());
    dom.scalpIndHardConf?.addEventListener("input", () => updateStateFromUI());
    dom.priceActionToggle?.addEventListener("change", () => updateStateFromUI());


    dom.chartAssistToggle?.addEventListener("change", () => updateStateFromUI());
    dom.chartAssistMode?.addEventListener("change", () => updateStateFromUI());
    dom.chartAssistMinCd?.addEventListener("input", () => updateStateFromUI());

    dom.toggleVisibilityBtn?.addEventListener("click", toggleTokenVisibility);
    dom.copyApiUrlBtn?.addEventListener("click", copyApiUrl);

    dom.analyzeBtn?.addEventListener("click", () => showInsight("sentiment"));
    dom.riskBtn?.addEventListener("click", () => showInsight("risk"));

    dom.symbolSelect?.addEventListener("change", (e) => setSymbol(e.target.value));
    dom.applySymbolBtn?.addEventListener("click", () => setSymbol(dom.customSymbol?.value));

    dom.placeTradeBtn?.addEventListener("click", () => manualPlaceTrade(1));
    dom.bulk3Btn?.addEventListener("click", () => manualPlaceTrade(3));
    dom.bulk5Btn?.addEventListener("click", () => manualPlaceTrade(5));
    dom.clearHistoryBtn?.addEventListener("click", clearHistory);

    dom.autoTradingToggle?.addEventListener("change", (e) => {
      appState.autoTradingEnabled = !!e.target.checked;
      logLine("Auto Trading: " + (appState.autoTradingEnabled ? "ON" : "OFF"));
      updateUI();
    });

    
    // =========================
    // Accumulator (True ACCU) wiring
    // =========================
    dom.accuToggle?.addEventListener("change", (e) => {
      appState.accu.enabled = !!e.target.checked;
      logLine("Accumulator: " + (appState.accu.enabled ? "ON" : "OFF"));
      updateUI();
    });

    dom.accuSafe?.addEventListener("change", (e) => {
      appState.accu.safe = !!e.target.checked;
      // if safe is ON, clamp growth to 12%
      if (appState.accu.safe && appState.accu.growthRate > 0.02){
        appState.accu.growthRate = 0.02;
      }
      logLine("Accumulator Safe Mode: " + (appState.accu.safe ? "ON" : "OFF"));
      updateUI();
      if (typeof setAccuBtnActive === "function") setAccuBtnActive();
    });

    dom.accuGrowth?.addEventListener("change", (e) => {
      let gr = Number(e.target.value);
      if (!Number.isFinite(gr)) gr = 0.01;
      if (appState.accu.safe) gr = Math.min(gr, 0.02); // safe cap
      // allow only 0.01..0.05
      gr = Math.max(0.01, Math.min(0.05, gr));
      appState.accu.growthRate = gr;
      logLine("Accumulator Growth Rate: " + Math.round(gr*100) + "%");
      updateUI();
      if (typeof setAccuBtnActive === "function") setAccuBtnActive();
    });

    // Growth rate bar (1%..5%) like Deriv app
    const accuBtns = Array.from(document.querySelectorAll("[data-accu-growth]"));
    function setAccuBtnActive(){
      const cur = Number(appState.accu.growthRate || 0.01);
      accuBtns.forEach(btn => {
        const v = Number(btn.getAttribute("data-accu-growth"));
        const isOn = Math.abs(v - cur) < 1e-9;
        btn.classList.toggle("bg-sky-600", isOn);
        btn.classList.toggle("text-white", isOn);
        btn.classList.toggle("bg-slate-700", !isOn);
        btn.classList.toggle("text-slate-200", !isOn);
      });
    }

    accuBtns.forEach(btn => {
      btn.addEventListener("click", () => {
        const raw = Number(btn.getAttribute("data-accu-growth"));
        if (!Number.isFinite(raw)) return;
        // safe cap
        let gr = Math.max(0.01, Math.min(0.05, raw));
        if (appState.accu.safe) gr = Math.min(gr, 0.02);
        appState.accu.growthRate = gr;
        if (dom.accuGrowth) dom.accuGrowth.value = String(gr);
        logLine("Accumulator Growth Rate: " + Math.round(gr*100) + "%");
        setAccuBtnActive();
        updateUI();
      });
    });

    // initial highlight
    setAccuBtnActive();


    dom.accuTP?.addEventListener("input", (e) => {
      const v = String(e.target.value || "").trim();
      if (!v){
        appState.accu.takeProfit = null;
      } else {
        const n = Number(v);
        appState.accu.takeProfit = Number.isFinite(n) && n > 0 ? n : null;
      }
    });
dom.clearLogBtn?.addEventListener("click", () => { if (LOG) LOG.textContent = ""; });
    dom.exportLogBtn?.addEventListener("click", async () => {
      try{
        await navigator.clipboard.writeText(LOG?.textContent || "");
        logLine("Log copied to clipboard.");
      }catch(e){
        logLine("Copy log failed.");
      }
    });

    dom.clearTxLogBtn?.addEventListener("click", () => { if (TXLOG) TXLOG.textContent = ""; txLogLine("CLEARED | Transaction log reset"); });
    dom.exportTxLogBtn?.addEventListener("click", async () => {
      try{
        await navigator.clipboard.writeText(TXLOG?.textContent || "");
        logLine("Transaction log copied to clipboard.");
      }catch(e){
        logLine("Copy transaction log failed.");
      }
    });

    updateConnection("DISCONNECTED", "bg-red-800 text-white");
    updateTradeStatus("Idle", "bg-slate-600 text-slate-300");
    setSellable(0);
    updateProfit(appState.sessionProfit);
    updateLoss(appState.sessionLoss);
    updateUI();

    logLine("Kut Milz TB loaded. Ready.");
    txLogLine("READY | Transaction log initialized");
  }catch(e){
    logLine("Init error: " + e.message);
  }
});</script>

<!-- ================= KUT MILZ ULTIMATE AI ENGINE ================= -->
<script>
/* =====================================================================
   KUT MILZ TB — ULTIMATE INSTITUTIONAL AI ENGINE (DERIV API)
   ===================================================================== */
const AI_KEY = "kut_milz_tb_ai_ultimate_v4";
let AI = JSON.parse(localStorage.getItem(AI_KEY)) || { symbols:{}, global:{wins:0,losses:0,kill:false} };
function saveAI(){ localStorage.setItem(AI_KEY, JSON.stringify(AI)); }
function getSymbol(symbol){
  if(!AI.symbols[symbol]){
    AI.symbols[symbol]={patterns:{},zones:{},stats:{w:0,l:0},confFloor:55,stakeBias:1,hourly:{},lastDecay:Date.now()};
  }
  return AI.symbols[symbol];
}
function extractPattern(ticks){
  if(!ticks||ticks.length<6) return "NONE";
  let p=""; for(let i=ticks.length-6;i<ticks.length-1;i++) p+=ticks[i+1]>ticks[i]?"U":"D";
  return p;
}
function zone(price){ return Math.floor(price/10)*10; }
function decay(ai){
  if(Date.now()-ai.lastDecay<3600000) return;
  for(const k in ai.patterns){ ai.patterns[k].w*=0.95; ai.patterns[k].l*=0.95; }
  ai.lastDecay=Date.now();
}
function adjustConf(ai){
  const t=ai.stats.w+ai.stats.l; if(t<25) return;
  const wr=ai.stats.w/t;
  if(wr>0.6) ai.confFloor=Math.max(45,ai.confFloor-2);
  if(wr<0.45) ai.confFloor=Math.min(70,ai.confFloor+3);
}
function globalRisk(){
  const t=AI.global.wins+AI.global.losses; if(t<20) return;
  if(AI.global.wins/t<0.4) AI.global.kill=true;
}
function stakeMult(ai,conf){
  let m=1; if(conf>80) m+=0.2; if(conf>90) m+=0.3;
  if(ai.stats.l>ai.stats.w) m-=0.2; if(AI.global.kill) m=0;
  return Math.max(0.5,Math.min(1.8,m));
}
function aiGate(symbol,pattern,z,conf){
  const ai=getSymbol(symbol); decay(ai); globalRisk();
  if(AI.global.kill) return {ok:false,reason:"GLOBAL KILL SWITCH"};
  if(conf<ai.confFloor) return {ok:false,reason:"CONF FLOOR"};
  if(ai.zones[z]>=3) return {ok:false,reason:"NO-TRADE ZONE"};
  const p=ai.patterns[pattern];
  if(p&&(p.l>p.w)&&(p.w+p.l>=6)) return {ok:false,reason:"BAD PATTERN"};
  return {ok:true};
}
function learn(symbol,pattern,z,win){
  const ai=getSymbol(symbol);
  if(!ai.patterns[pattern]) ai.patterns[pattern]={w:0,l:0};
  win?ai.patterns[pattern].w++:ai.patterns[pattern].l++;
  if(!ai.zones[z]) ai.zones[z]=0; if(!win) ai.zones[z]++;
  win?ai.stats.w++:ai.stats.l++; win?AI.global.wins++:AI.global.losses++;
  adjustConf(ai); saveAI();
}
function renderAI(symbol){
  const ai=getSymbol(symbol);
  const el=document.getElementById("ai-stats-panel"); if(!el) return;
  el.innerHTML=`<b>ULTIMATE AI ENGINE</b><br>
  Symbol: ${symbol}<br>
  Wins: ${ai.stats.w} | Losses: ${ai.stats.l}<br>
  Confidence Floor: ${ai.confFloor}%<br>
  Patterns: ${Object.keys(ai.patterns).length}<br>
  No-Trade Zones: ${Object.keys(ai.zones).length}<br>
  Global Kill: ${AI.global.kill}`;
}
console.log("KUT MILZ AI ENGINE ACTIVE");
</script>
<!-- ================================================================ -->


<!-- ================= AI FULL WIRING ================= -->
<script>
(function(){
  console.log("AI FULL WIRING INIT");

  // helpers
  function getConfidence(){
    const el=document.getElementById("confidence-text");
    return el?parseFloat(el.innerText)||0:0;
  }
  function getSymbol(){
    const el=document.getElementById("currentSymbolLabel");
    return el?el.innerText:"UNKNOWN";
  }
  function getPrice(){
    return window.lastTickPrice||0;
  }

  // tick capture (safe)
  window.tickHistory = window.tickHistory || [];
  const _pushTick = window.onNewTick;
  window.onNewTick = function(price){
    window.lastTickPrice = price;
    tickHistory.push(price);
    if(tickHistory.length>50) tickHistory.shift();
    if(typeof _pushTick==="function") _pushTick(price);
  };

  // PRE-TRADE GATE
  const btn=document.getElementById("placeTradeBtn");
  if(btn){
    btn.addEventListener("click", function(e){
      const symbol=getSymbol();
      const conf=getConfidence();
      const pat=extractPattern(tickHistory);
      const z=zone(getPrice());
      const gate=aiGate(symbol,pat,z,conf);
      if(!gate.ok){
        e.stopImmediatePropagation();
        document.getElementById("block-reason-display").innerText=gate.reason;
        console.warn("AI BLOCK:",gate.reason);
        return false;
      }
    }, true);
  }

  // POST-TRADE LEARN (watch tx log)
  const tx=document.getElementById("tx-log");
  if(tx){
    const obs=new MutationObserver(()=>{
      const txt=tx.innerText.trim().split("\n").pop()||"";
      if(txt.includes("CLOSED")){
        const win=!txt.includes("-");
        const symbol=getSymbol();
        const pat=extractPattern(tickHistory);
        const z=zone(getPrice());
        learn(symbol,pat,z,win);
        renderAI(symbol);
      }
    });
    obs.observe(tx,{childList:true,subtree:true});
  }

  // dashboard mount
  if(!document.getElementById("ai-stats-panel")){
    const div=document.createElement("div");
    div.id="ai-stats-panel";
    div.className="card text-xs";
    document.querySelector(".container-wrapper")?.appendChild(div);
  }

  console.log("AI FULLY WIRED AND ACTIVE");
})();
</script>
<!-- ================================================== -->


<!-- ================= AI ENHANCEMENTS ================= -->
<script>
(function(){
  // === USER CONTROLS (SAFE DEFAULTS) ===
  window.AI_USER_SETTINGS = JSON.parse(localStorage.getItem("AI_USER_SETTINGS")) || {
    stakeScaling: false,   // manual by default
    alwaysLearning: true   // learning always ON
  };

  function saveSettings(){
    localStorage.setItem("AI_USER_SETTINGS", JSON.stringify(AI_USER_SETTINGS));
  }

  // === TIME-OF-DAY LEARNING ===
  const _learn = window.learn;
  window.learn = function(symbol, pattern, z, win){
    const hour = new Date().getHours();
    const ai = getSymbol(symbol);
    if(!ai.hourly[hour]) ai.hourly[hour] = {w:0,l:0};
    win ? ai.hourly[hour].w++ : ai.hourly[hour].l++;
    _learn(symbol, pattern, z, win);
  };

  // === STAKE SCALING (OPTIONAL) ===
  const _stakeCalc = window.calculateStake;
  window.calculateStake = function(baseStake, symbol, confidence){
    let stake = baseStake;
    if(AI_USER_SETTINGS.stakeScaling){
      const ai = getSymbol(symbol);
      stake *= stakeMult(ai, confidence);
    }
    return stake;
  };

  // === AI GATE UNLOCK (MANUAL OVERRIDE) ===
  window.AI_UNLOCK = function(){
    AI.global.kill = false;
    saveAI();
    alert("AI kill-switch unlocked manually");
  };

  // === UI CONTROLS ===
  const panel = document.getElementById("ai-stats-panel");
  if(panel){
    const controls = document.createElement("div");
    controls.innerHTML = `
      <hr>
      <label><input type="checkbox" id="aiStakeToggle"> AI Stake Scaling</label><br>
      <button id="aiUnlockBtn">Unlock AI (Kill Switch)</button>
    `;
    panel.appendChild(controls);

    const stakeToggle = document.getElementById("aiStakeToggle");
    stakeToggle.checked = AI_USER_SETTINGS.stakeScaling;
    stakeToggle.onchange = () => {
      AI_USER_SETTINGS.stakeScaling = stakeToggle.checked;
      saveSettings();
    };

    document.getElementById("aiUnlockBtn").onclick = window.AI_UNLOCK;
  }

  console.log("AI ENHANCEMENTS ACTIVE");
})();
</script>
<!-- ================================================ -->


<!-- ================= AI MODES & CONTROLS ================= -->
<script>
(function(){

  // === USER MODES ===
  window.AI_USER_SETTINGS = JSON.parse(localStorage.getItem("AI_USER_SETTINGS")) || {
    stakeScaling:false,
    alwaysLearning:true,
    mode:"conservative", // conservative | aggressive
    hourBlocking:true
  };

  function saveSettings(){
    localStorage.setItem("AI_USER_SETTINGS", JSON.stringify(AI_USER_SETTINGS));
  }

  // === AGGRESSIVE / CONSERVATIVE MODE ===
  const _aiGate = window.aiGate;
  window.aiGate = function(symbol, pattern, z, conf){
    const res = _aiGate(symbol, pattern, z, conf);
    const ai = getSymbol(symbol);

    if(AI_USER_SETTINGS.mode === "aggressive"){
      ai.confFloor = Math.max(40, ai.confFloor - 5);
    } else {
      ai.confFloor = Math.min(70, ai.confFloor + 0);
    }

    // Hour-based blocking
    if(AI_USER_SETTINGS.hourBlocking){
      const hour = new Date().getHours();
      const h = ai.hourly[hour];
      if(h && h.l > h.w + 2){
        return {ok:false, reason:"BAD HOUR"};
      }
    }
    return res;
  };

  // === RESET PER SYMBOL ===
  window.resetAISymbol = function(symbol){
    if(!AI.symbols[symbol]) return;
    delete AI.symbols[symbol];
    saveAI();
    alert("AI reset for " + symbol);
  };

  // === UI CONTROLS ===
  const panel = document.getElementById("ai-stats-panel");
  if(panel){
    const controls = document.createElement("div");
    controls.innerHTML = `
      <hr>
      <label>AI Mode:</label>
      <select id="aiModeSel">
        <option value="conservative">Conservative</option>
        <option value="aggressive">Aggressive</option>
      </select><br>
      <label><input type="checkbox" id="aiHourBlock"> Hour-based Blocking</label><br>
      <button id="aiResetSym">Reset AI (This Symbol)</button>
    `;
    panel.appendChild(controls);

    const sel=document.getElementById("aiModeSel");
    sel.value = AI_USER_SETTINGS.mode;
    sel.onchange=()=>{ AI_USER_SETTINGS.mode=sel.value; saveSettings(); };

    const hb=document.getElementById("aiHourBlock");
    hb.checked = AI_USER_SETTINGS.hourBlocking;
    hb.onchange=()=>{ AI_USER_SETTINGS.hourBlocking=hb.checked; saveSettings(); };

    document.getElementById("aiResetSym").onclick=()=>{
      const s=document.getElementById("currentSymbolLabel")?.innerText;
      if(s) resetAISymbol(s);
    };
  }

  console.log("AI MODES + HOUR BLOCKING ACTIVE");
})();
</script>
<!-- ================================================ -->


<!-- ================= AI VISUALS & EXPORT ================= -->
<script>
(function(){

  // === PER-HOUR STAKE BIAS ===
  const _stakeMult = window.stakeMult;
  window.stakeMult = function(ai, conf){
    let m = _stakeMult(ai, conf);
    const hour = new Date().getHours();
    const h = ai.hourly?.[hour];
    if(h && h.w + h.l >= 5){
      const wr = h.w / (h.w + h.l);
      if(wr > 0.65) m += 0.2;
      if(wr < 0.4) m -= 0.2;
    }
    return Math.max(0.5, Math.min(2.0, m));
  };

  // === AUTO MODE SWITCH BASED ON STRONG HOURS ===
  setInterval(()=>{
    const symbol = document.getElementById("currentSymbolLabel")?.innerText;
    if(!symbol) return;
    const ai = getSymbol(symbol);
    const hour = new Date().getHours();
    const h = ai.hourly?.[hour];
    if(!h || h.w + h.l < 6) return;
    const wr = h.w / (h.w + h.l);
    if(wr > 0.7) AI_USER_SETTINGS.mode = "aggressive";
    if(wr < 0.45) AI_USER_SETTINGS.mode = "conservative";
    localStorage.setItem("AI_USER_SETTINGS", JSON.stringify(AI_USER_SETTINGS));
  }, 60000);

  // === HOUR HEATMAP ===
  window.renderHourHeatmap = function(symbol){
    const ai = getSymbol(symbol);
    let html = "<b>Hour Heatmap</b><table style='width:100%;font-size:10px'><tr>";
    for(let h=0;h<24;h++){
      const d = ai.hourly[h] || {w:0,l:0};
      const t = d.w + d.l;
      let c = "#333";
      if(t>=5){
        const wr = d.w/t;
        if(wr>0.65) c="#1f7";
        else if(wr<0.4) c="#f55";
        else c="#ffb";
      }
      html += `<td style="padding:2px;background:${c}">${h}</td>`;
      if(h===11) html += "</tr><tr>";
    }
    html += "</tr></table>";
    return html;
  };

  // attach heatmap to panel
  const _renderAI = window.renderAI;
  window.renderAI = function(symbol){
    _renderAI(symbol);
    const el=document.getElementById("ai-stats-panel");
    if(el) el.innerHTML += renderHourHeatmap(symbol);
  };

  // === EXPORT AI PERFORMANCE ===
  window.exportAIJSON = function(){
    const data = JSON.stringify(AI, null, 2);
    download(data, "ai_performance.json", "application/json");
  };

  window.exportAICSV = function(){
    let csv = "symbol,hour,wins,losses\n";
    for(const s in AI.symbols){
      const ai = AI.symbols[s];
      for(const h in ai.hourly){
        csv += `${s},${h},${ai.hourly[h].w},${ai.hourly[h].l}\n`;
      }
    }
    download(csv, "ai_performance.csv", "text/csv");
  };

  function download(data, name, type){
    const a=document.createElement("a");
    a.href=URL.createObjectURL(new Blob([data],{type}));
    a.download=name;
    a.click();
  }

  // === EXPORT BUTTONS ===
  const panel=document.getElementById("ai-stats-panel");
  if(panel){
    const btns=document.createElement("div");
    btns.innerHTML=`
      <hr>
      <button onclick="exportAIJSON()">Export AI (JSON)</button>
      <button onclick="exportAICSV()">Export AI (CSV)</button>
    `;
    panel.appendChild(btns);
  }

  console.log("AI VISUALS + EXPORT ACTIVE");
})();
</script>
<!-- ================================================ -->


<!-- ================= AI IMPORT BUTTON ================= -->
<script>
(function(){

  // === IMPORT AI MEMORY ===
  window.importAIFromFile = function(file){
    const reader = new FileReader();
    reader.onload = function(e){
      try{
        const data = JSON.parse(e.target.result);
        if(!data.symbols || !data.global){
          alert("Invalid AI file");
          return;
        }
        AI = data;
        saveAI();
        alert("AI memory imported successfully");
        const sym=document.getElementById("currentSymbolLabel")?.innerText;
        if(sym) renderAI(sym);
      }catch(err){
        alert("Failed to import AI memory");
      }
    };
    reader.readAsText(file);
  };

  // === ADD UI ===
  const panel = document.getElementById("ai-stats-panel");
  if(panel){
    const div = document.createElement("div");
    div.innerHTML = `
      <hr>
      <input type="file" id="aiImportFile" accept=".json">
      <button id="aiImportBtn">Import AI</button>
    `;
    panel.appendChild(div);

    document.getElementById("aiImportBtn").onclick = function(){
      const f=document.getElementById("aiImportFile").files[0];
      if(!f){ alert("Select AI JSON file first"); return; }
      importAIFromFile(f);
    };
  }

  console.log("AI IMPORT BUTTON ACTIVE");
})();
</script>
<!-- ================================================ -->


<!-- ================= AI AUTO EXPORT TIMER ================= -->
<script>
(function(){

  // === AUTO EXPORT SETTINGS ===
  window.AI_EXPORT_SETTINGS = JSON.parse(localStorage.getItem("AI_EXPORT_SETTINGS")) || {
    enabled: false,
    intervalMin: 30, // default 30 minutes
    lastExport: 0
  };

  function saveExportSettings(){
    localStorage.setItem("AI_EXPORT_SETTINGS", JSON.stringify(AI_EXPORT_SETTINGS));
  }

  function autoExport(){
    if(!AI_EXPORT_SETTINGS.enabled) return;
    const now = Date.now();
    if(now - AI_EXPORT_SETTINGS.lastExport < AI_EXPORT_SETTINGS.intervalMin * 60000) return;

    const data = JSON.stringify(AI, null, 2);
    const a = document.createElement("a");
    a.href = URL.createObjectURL(new Blob([data], {type:"application/json"}));
    a.download = "ai_auto_backup.json";
    a.click();

    AI_EXPORT_SETTINGS.lastExport = now;
    saveExportSettings();
    console.log("AI auto-backup exported");
  }

  // run timer every minute
  setInterval(autoExport, 60000);

  // === UI CONTROLS ===
  const panel = document.getElementById("ai-stats-panel");
  if(panel){
    const div = document.createElement("div");
    div.innerHTML = `
      <hr>
      <label>
        <input type="checkbox" id="aiAutoExportToggle">
        Auto Export AI
      </label><br>
      <label>
        Interval (minutes):
        <input type="number" id="aiExportInterval" min="5" step="5" style="width:60px">
      </label>
    `;
    panel.appendChild(div);

    const tgl = document.getElementById("aiAutoExportToggle");
    const inp = document.getElementById("aiExportInterval");

    tgl.checked = AI_EXPORT_SETTINGS.enabled;
    inp.value = AI_EXPORT_SETTINGS.intervalMin;

    tgl.onchange = ()=>{
      AI_EXPORT_SETTINGS.enabled = tgl.checked;
      saveExportSettings();
    };

    inp.onchange = ()=>{
      AI_EXPORT_SETTINGS.intervalMin = Math.max(5, parseInt(inp.value)||30);
      saveExportSettings();
    };
  }

  console.log("AI AUTO EXPORT TIMER ACTIVE");
})();
</script>
<!-- ======================================================= -->


<script>
document.addEventListener("AI_TRADE", e => {
  const d = e.detail;
  if(window.AI && d){
    AI.recordTrade({
      symbol: d.symbol,
      result: d.win ? "win" : "loss",
      stake: d.stake,
      payout: d.payout
    });
  }
});
</script>


<!-- BEGIN: KUTMILZAI WELCOME POPUP (added) -->
<style id="kut-welcome-style">
  #kut-welcome-popup{
    position: fixed;
    z-index: 99999;
    left: 50%;
    top: 14%;
    transform: translateX(-50%) translateY(-10px);
    width: min(760px, 90%);
    max-width: 760px;
    background: linear-gradient(180deg, #0b1c2d, #0a1524);
    color: #f5d98c;
    border-radius: 14px;
    padding: 18px 20px;
    box-shadow: 0 18px 60px rgba(0,0,0,0.55);
    border: 1px solid rgba(245,217,140,0.25);
    opacity: 0;
    pointer-events: none;
    transition: opacity 300ms ease, transform 300ms ease;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  }
  #kut-welcome-popup.visible{
    opacity: 1;
    pointer-events: auto;
    transform: translateX(-50%) translateY(0);
  }
  #kut-welcome-popup .kut-row{
    display:flex;
    gap:12px;
    align-items:flex-start;
  }
  #kut-welcome-popup .kut-emoji{
    font-size: 36px;
    line-height: 1;
    margin-top:2px;
  }
  #kut-welcome-popup h3{ color:#f8e3a1;
    margin:0;
    font-size:18px;
    font-weight:800;
    letter-spacing:0.02em;
  }
  #kut-welcome-popup p{ color:#f5e7b2;
    margin:6px 0 0 0;
    font-size:13px;
    color: #26303f;
    line-height:1.35;
    font-weight:600;
  }
  #kut-welcome-popup .kut-actions{
    margin-top:10px;
    display:flex;
    justify-content:flex-end;
    gap:8px;
  }
  #kut-welcome-popup button.kut-close{
    background:rgba(245,217,140,0.08);
    border:1px solid rgba(245,217,140,0.35); color:#f5d98c;
    padding:8px 12px;
    border-radius:10px;
    font-weight:700;
    cursor:pointer;
  }
  @media (max-width:640px){
    #kut-welcome-popup{
    position: fixed;
    z-index: 99999;
    left: 50%;
    top: 14%;
    transform: translateX(-50%) translateY(-10px);
    width: min(760px, 90%);
    max-width: 760px;
    background: linear-gradient(180deg, #0b1c2d, #0a1524);
    color: #f5d98c;
    border-radius: 14px;
    padding: 18px 20px;
    box-shadow: 0 18px 60px rgba(0,0,0,0.55);
    border: 1px solid rgba(245,217,140,0.25);
    opacity: 0;
    pointer-events: none;
    transition: opacity 300ms ease, transform 300ms ease;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  }
    #kut-welcome-popup .kut-emoji{ font-size:28px; }
    #kut-welcome-popup h3{ color:#f8e3a1; font-size:16px; }
  }
</style>

<div id="kut-welcome-popup" role="dialog" aria-live="polite" aria-label="Welcome to KutMilzAi">
  <div class="kut-row">
    <div class="kut-emoji" aria-hidden="true">✅</div>
    <div style="flex:1">
      <h3>Welcome to the KutMilzAi</h3>
      <p><strong>Always remember to follow the rules. If you break the rules without experience, that can lead to your account being affected. Never get greedy. Enjoy your session 😊✨</p>
      <div class="kut-actions">
        <button class="kut-close" title="Close (hide now)">Close</button>
      </div>
    </div>
  </div>
</div>

<script id="kut-welcome-script">
(function(){
  try{
    const popup = document.getElementById("kut-welcome-popup");
    if(!popup) return;
    // Show on DOMContentLoaded
    function show(){
      popup.classList.add("visible");
      // Auto-hide after 10 seconds (10000 ms)
      setTimeout(()=>{
        popup.classList.remove("visible");
      }, 10000);
    }
    // Attach close button
    const btn = popup.querySelector(".kut-close");
    if(btn) btn.addEventListener("click", ()=> popup.classList.remove("visible"));
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", show);
    } else {
      show();
    }
  }catch(e){ console.warn("Welcome popup error:", e); }
})();
</script>
<!-- END: KUTMILZAI WELCOME POPUP -->

<!-- BEGIN: KUTMILZAI RISK NOTICES (added) -->
<style id="kut-risk-style">
  .kut-risk-popup{
    position: fixed;
    z-index: 999999;
    left: 50%;
    transform: translateX(-50%);
    width: min(720px, 92%);
    max-width: 720px;
    background: linear-gradient(180deg, #0b1c2d, #081122);
    color: #f5d98c;
    border-radius: 12px;
    padding: 16px 18px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.6);
    border: 1px solid rgba(245,217,140,0.22);
    opacity: 0;
    pointer-events: none;
    transition: opacity 260ms ease, transform 260ms ease;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    display:flex;
    gap:12px;
    align-items:flex-start;
  }
  .kut-risk-popup.visible{ opacity:1; pointer-events:auto; transform: translateX(-50%) translateY(0); }
  .kut-risk-emoji{ font-size:34px; line-height:1; margin-top:2px; }
  .kut-risk-body{ flex:1; }
  .kut-risk-body h4{ margin:0; font-size:15px; font-weight:800; color:#f8e3a1; }
  .kut-risk-body p{ margin:6px 0 0 0; font-size:13px; color:#f5e7b2; line-height:1.35; font-weight:600; }
  .kut-risk-actions{ margin-top:10px; display:flex; justify-content:flex-end; gap:8px; }
  .kut-risk-popup button.kut-close{ background:rgba(245,217,140,0.08); border:1px solid rgba(245,217,140,0.28); padding:8px 12px; border-radius:10px; font-weight:700; cursor:pointer; color:#f5d98c; }
  /* positions */
  #kut-greed-note{ top: 22%; }
  #kut-drawdown-popup{ bottom: 8%; }
  @media (max-width:640px){
    .kut-risk-popup{ left:50%; transform:translateX(-50%); width:92%; padding:12px; border-radius:10px; }
    .kut-risk-emoji{ font-size:28px; }
  }
</style>

<!-- Greed note popup (shows after welcome or when triggered) -->
<div id="kut-greed-note" class="kut-risk-popup" role="status" aria-live="polite" aria-label="Greed warning">
  <div class="kut-risk-emoji" aria-hidden="true">✅</div>
  <div class="kut-risk-body">
    <h4>Note — Don't get greedy</h4>
    <p>Remember not to get greedy — you're on three clean wins. Lower your stake if the stake is above 50% of the balance.</p>
    <div class="kut-risk-actions"><button class="kut-close">Close</button></div>
  </div>
</div>

<!-- Drawdown popup (trigger manually or by detection) -->
<div id="kut-drawdown-popup" class="kut-risk-popup" role="alert" aria-live="assertive" aria-label="Drawdown detected">
  <div class="kut-risk-emoji" aria-hidden="true">⚠️</div>
  <div class="kut-risk-body">
    <h4>Caution — Drawdown detected</h4>
    <p>Lock auto trades off and let the AI observe — you're in a drawdown!</p>
    <div class="kut-risk-actions"><button class="kut-close">Close</button></div>
  </div>
</div>

<script id="kut-risk-script">
(function(){
  try{
    const greed = document.getElementById("kut-greed-note");
    const draw = document.getElementById("kut-drawdown-popup");

    function hide(el){ el.classList.remove("visible"); }
    function show(el, duration=null){
      if(!el) return;
      el.classList.add("visible");
      if(duration && duration>0){
        setTimeout(()=> hide(el), duration);
      }
    }

    // Close buttons
    document.querySelectorAll(".kut-risk-popup .kut-close").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const pop = btn.closest(".kut-risk-popup");
        if(pop) hide(pop);
      });
    });

    // Public triggers (call these from your bot when you detect conditions)
    window.triggerGreedNotePopup = function(opts){
      // opts: {durationMs: number}
      const dur = (opts && opts.durationMs) || 10000;
      show(greed, dur);
    };
    window.triggerDrawdownPopup = function(opts){
      const dur = (opts && opts.durationMs) || 15000;
      show(draw, dur);
    };

    // Auto-show greed note once after the welcome popup hides (non-invasive)
    (function autoGreedAfterWelcome(){
      // New behavior: wait until the welcome popup hides, then listen for a streak === 3 event.
      // When the streak reaches 3 for the first time after welcome, show a two-stage message:
      //  1) softer message (as requested): shown immediately when streak hits 3
      //  2) final warning message: shown shortly after the first message
      const welcome = document.getElementById("kut-welcome-popup");
      let afterWelcome = false;
      let checkInterval = null;

      function startListeningForStreak(){
        if(checkInterval) return;
        checkInterval = setInterval(()=>{
          try{
            // look for common streak variable names
            const streakNames = ["winStreak","streak","consecutiveWins","winsInRow","wins"];
            let streak = undefined;
            for(const n of streakNames){
              try{ const v = window[n]; if(typeof v !== "undefined"){ streak = Number(v); break; } }catch(e){}
            }
            // Also accept a provided function
            const fnCandidates = ["getWinStreak","fetchWinStreak"];
            if(typeof streak === "undefined"){
              for(const fn of fnCandidates){
                try{ if(typeof window[fn] === "function"){ const r = window[fn](); if(typeof r !== "undefined"){ streak = Number(r); break; } }}catch(e){}
              }
            }

            if(typeof streak === "number" && !isNaN(streak) && streak >= 3){
              // show initial softer message as the user requested (first message after welcome)
              const greed = document.getElementById("kut-greed-note");
              if(greed){
                greed.querySelector(".kut-risk-body h4").textContent = "Note — Don't get greedy";
                greed.querySelector(".kut-risk-body p").textContent = "Remember not to get greedy — if your on three clean wins. Lower your stake if the stake is above 50% of your balance.";
                // show it for 9 seconds
                greed.classList.add("visible");
                setTimeout(()=>{
                  greed.classList.remove("visible");
                  // after the softer message, show the final warning message
                  setTimeout(()=>{
                    if(greed){
                      greed.querySelector(".kut-risk-body h4").textContent = "Final Warning — Risk Management Comes First";
                      greed.querySelector(".kut-risk-body p").textContent = "Remember not to get greedy — you\u2019re on three clean wins. Lower your stake if the stake is above 50% of your balance. Final Warning: Risk Management Comes First.";
                      greed.classList.add("visible");
                      // show final warning for 12 seconds
                      setTimeout(()=>{ greed.classList.remove("visible"); }, 12000);
                    }
                  }, 700); // short delay before final warning
                }, 9000);
              }
              // stop checking after first trigger to avoid repeating
              clearInterval(checkInterval);
              checkInterval = null;
            }
          }catch(e){ /* fail silently */ }
        }, 1200);
        // stop listening after 10 minutes as safety
        setTimeout(()=>{ if(checkInterval) clearInterval(checkInterval); checkInterval = null; }, 1000*60*10);
      }

      if(welcome){
        // observe class changes to detect when welcome becomes hidden
        const obs = new MutationObserver(()=>{
          if(!welcome.classList.contains("visible")){
            afterWelcome = true;
            startListeningForStreak();
            obs.disconnect();
          }
        });
        obs.observe(welcome, {attributes:true, attributeFilter:['class']});
      } else {
        // if no welcome, start listening after DOM ready
        if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", startListeningForStreak);
        else startListeningForStreak();
      }
    })();

    // --- Simple, safe auto-detection for drawdown / greedy stake ---
    // This is intentionally conservative: it only reads existing globals if present and won't create or overwrite anything.
    function firstDefined(names){
      for(const n of names){
        try{
          const v = window[n];
          if(typeof v !== "undefined") return v;
        }catch(e){}
      }
      return undefined;
    }

    function getNumberFromCandidates(cands){
      const v = firstDefined(cands);
      if(typeof v === "number") return v;
      if(typeof v === "string" && !isNaN(Number(v))) return Number(v);
      return undefined;
    }

    // candidate variable names commonly used by trading UI code
    const balanceNames = ["balance","accountBalance","currentBalance","funds","walletBalance"];
    const stakeNames = ["stake","currentStake","betAmount","wager"];
    const streakNames = ["winStreak","streak","consecutiveWins","winsInRow"];
    const startingBalanceNames = ["startingBalance","initialBalance","startingAccountBalance"];

    // detection thresholds
    const DRAWdown_PERCENT = 0.10; // 10% drawdown threshold if starting balance known
    const POLL_MS = 3000;
    let seenGreedTrigger = false;
    let seenDrawdownTrigger = false;
    let lastKnownStartingBalance = getNumberFromCandidates(startingBalanceNames);

    // try to initialize starting balance if there's a function or variable that provides it
    if(!lastKnownStartingBalance){
      const fnCandidates = ["getStartingBalance","fetchStartingBalance"];
      for(const fn of fnCandidates){
        try{ if(typeof window[fn] === "function"){ const res = window[fn](); if(typeof res === "number") lastKnownStartingBalance = res; }}catch(e){}
      }
    }

    function poll(){
      try{
        const balance = getNumberFromCandidates(balanceNames);
        const stake = getNumberFromCandidates(stakeNames);
        const streak = getNumberFromCandidates(streakNames);
        if(balance !== undefined && stake !== undefined && streak !== undefined && !seenGreedTrigger){
          // If user is on three clean wins and stake > 50% balance => show greed note
          if(streak >= 3 && stake > 0.5 * balance){
            seenGreedTrigger = true;
            window.triggerGreedNotePopup({durationMs:12000});
          }
        }

        // Drawdown detection: if starting balance known and current balance dropped by DRAWdown_PERCENT
        let startBal = lastKnownStartingBalance;
        if(!startBal){
          startBal = getNumberFromCandidates(startingBalanceNames);
        }
        if(balance !== undefined && startBal !== undefined && !seenDrawdownTrigger){
          const drop = (startBal - balance) / startBal;
          if(drop >= DRAWdown_PERCENT){
            seenDrawdownTrigger = true;
            window.triggerDrawdownPopup({durationMs:20000});
          }
        }

        // Also detect if a drawdownPercent variable exists directly
        const dd = getNumberFromCandidates(["drawdownPercent","currentDrawdownPercent"]);
        if(typeof dd === "number" && dd >= DRAWdown_PERCENT && !seenDrawdownTrigger){
          seenDrawdownTrigger = true;
          window.triggerDrawdownPopup({durationMs:20000});
        }

      }catch(e){ /* fail silently */ }
    }

    // Start polling but only if at least one of the candidate variables exists to avoid unnecessary work
    const anyKnown = firstDefined(balanceNames.concat(stakeNames).concat(streakNames).concat(startingBalanceNames).concat(["drawdownPercent","currentDrawdownPercent"]));
    if(typeof anyKnown !== "undefined"){
      // poll a few times to catch transient conditions
      poll();
      const pollInterval = setInterval(poll, POLL_MS);
      // stop polling after 5 minutes to be non-intrusive
      setTimeout(()=> clearInterval(pollInterval), 1000 * 60 * 5);
    }

    // Expose a small helper to manually reset auto-triggers if you want
    window.__kut_reset_risk_triggers = function(){ seenGreedTrigger = false; seenDrawdownTrigger = false; };

  }catch(err){ console.warn("kut-risk script error", err); }
})();
</script>
<!-- END: KUTMILZAI RISK NOTICES -->
<script>
(function () {

  // 1️⃣ DEFINE FUNCTION FIRST
  function resolveTradeValues(tx) {
    let stake = 'N/A';
    let payout = 'N/A';

    if (typeof tx.stake === 'number' && tx.stake > 0) {
      stake = tx.stake;
    } else if (typeof tx.amount === 'number' && tx.amount > 0) {
      stake = tx.amount;
    } else if (typeof window.lastStake === 'number' && window.lastStake > 0) {
      stake = window.lastStake;
    } else if (typeof window.tradeAmount === 'number' && window.tradeAmount > 0) {
      stake = window.tradeAmount;
    }

    if (typeof tx.payout === 'number' && tx.payout > 0) {
      payout = tx.payout;
    } else if (typeof tx.profit === 'number' && tx.profit > 0) {
      payout = tx.profit;
    } else if (typeof tx.payoutAmount === 'number' && tx.payoutAmount > 0) {
      payout = tx.payoutAmount;
    }

    return { stake, payout };
  }

  // 2️⃣ EVENT LISTENER AFTER
  window.addEventListener('kut:transaction', function (e) {
    const tx = e.detail || {};
    console.log('TX DETAIL:', tx);

    const { stake, payout } = resolveTradeValues(tx);

    const symbol =
      tx.symbol ||
      tx.symbolName ||
      tx.market ||
      window.currentSymbol ||
      window.activeSymbol ||
      window.marketSymbol ||
      'UNKNOWN';

    const time = new Date().toLocaleTimeString();

    const card = document.createElement('div');
    card.innerHTML =
      '<div><b>MilzAI Alert 🔥</b></div>' +
      '<div>Symbol: ' + symbol + '</div>' +
      '<div>Time: ' + time + '</div>' +
      '<div>Stake: ' + stake + '</div>' +
      '<div>Payout: ' + payout + '</div>';

    document.body.appendChild(card);
    setTimeout(() => card.remove(), 8000);
  });

})();
</script>

<script src="./ai_performance.js"></script>

<!-- BEGIN: KUTMILZ TRANSACTION POPUP FIX (ADDED BY CHATGPT) -->
<style id="kut-tx-popup-style">
.kut-tx-stack{ position: fixed; right: 18px; bottom: 18px; z-index: 200000; display:flex; flex-direction: column; gap:10px; align-items: flex-end; pointer-events: none; }
.kut-tx-popup{
  min-width: 260px;
  max-width: 380px;
  background: linear-gradient(180deg,#071a2b,#0b2a44);
  color: #f5e6b8;
  border-radius: 12px;
  padding: 10px 12px;
  box-shadow: 0 12px 36px rgba(2,6,23,0.6);
  border: 1px solid rgba(212,175,55,0.35);
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
  pointer-events: auto;
  transform: translateY(12px) scale(.98);
  opacity: 0;
  transition: opacity 220ms ease, transform 220ms ease;
}
.kut-tx-popup.kut-visible{ opacity: 1; transform: translateY(0) scale(1); }
.kut-tx-popup .kut-row{ display:flex; align-items:center; gap:10px; }
.kut-tx-popup .kut-symbol{ font-weight:800; font-size:14px; color:#e8d28a; }
.kut-tx-popup .kut-status{ font-weight:800; padding:6px 8px; border-radius:8px; font-size:12px; }
.kut-tx-popup .kut-close-btn{ background:transparent; border:0; color:rgba(230,230,230,0.6); cursor:pointer; font-weight:700; }
.kut-tx-popup .kut-meta{ font-size:12px; color:rgba(230,230,230,0.75); margin-top:6px; display:flex; justify-content:space-between; gap:8px; }
.kut-tx-popup .kut-win{ background: linear-gradient(90deg,#1e7b3a,#12b76a); color:white; }
.kut-tx-popup .kut-lost{ background: linear-gradient(90deg,#b02a37,#f43f5e); color:white; }
</style>

<div id="kut-tx-stack" class="kut-tx-stack" aria-hidden="true" ></div>

<script id="kut-tx-popup-fix">
(function(){
  // Ensure stack exists
  const stack = document.getElementById("kut-tx-stack") || (function(){
    const s = document.createElement("div"); s.id="kut-tx-stack"; s.className="kut-tx-stack"; document.body.appendChild(s); return s;
  })();

  // Utility to format currency-ish
  function fmtNum(v){
    if (v === null || typeof v === "undefined") return "-";
    const n = Number(v);
    if (isNaN(n)) return String(v);
    return (n >= 0 ? "+" : "") + n.toFixed(2);
  }

  // create popup
  window.showTransactionPopup = function(data){
    try{
      const id = "kut-tx-" + Date.now() + "-" + Math.floor(Math.random()*1000);
      const d = data || {};
      const symbol = d.symbol || d.market || d.symbolName || "UNKNOWN";
      const stake = (typeof d.stake !== "undefined" && d.stake !== null) ? d.stake : (d.amount || "-");
      const payout = (typeof d.payout !== "undefined" && d.payout !== null) ? d.payout : (d.profit || "-");
      const status = (d.status || "").toString().toUpperCase();
      const cls = (status.indexOf("WON") >= 0 || Number(payout) > 0) ? "kut-win" : "kut-lost";

      const el = document.createElement("div");
      el.className = "kut-tx-popup";
      el.id = id;
      el.setAttribute("role","status");
      el.setAttribute("aria-live","polite");
      el.innerHTML = `
        <div class="kut-row">
          <div style="flex:1">
            <div class="kut-symbol">${symbol}</div>
            <div style="margin-top:6px; font-size:13px; color:rgba(230,230,230,0.9)">${d.note || ""}</div>
          </div>
          <div style="display:flex;flex-direction:column;align-items:flex-end;gap:6px">
            <div class="kut-status ${cls}">${status || "CLOSED"}</div>
            <button class="kut-close-btn" aria-label="Close">✕</button>
          </div>
        </div>
        <div class="kut-meta">
          <div>Stake: ${fmtNum(stake)}</div>
          <div>Payout: ${fmtNum(payout)}</div>
        </div>
      `;

      // close handler
      const closeBtn = el.querySelector(".kut-close-btn");
      closeBtn && closeBtn.addEventListener("click", ()=> removePopup(el));
      stack.appendChild(el);
      // force reflow then show
      requestAnimationFrame(()=> el.classList.add("kut-visible"));

      // Auto remove after 7s
      const to = setTimeout(()=> removePopup(el), 7000);

      function removePopup(node){
        if(!node) return;
        node.classList.remove("kut-visible");
        setTimeout(()=> { try{ node.remove(); }catch(e){} }, 260);
        clearTimeout(to);
      }

    }catch(e){
      console.warn("showTransactionPopup error", e);
    }
  };

  // also listen directly to the global event so the popup shows even if other listeners fail
  window.addEventListener("kut:transaction", (ev) => {
    if(ev && ev.detail) {
      try { window.showTransactionPopup(ev.detail); } catch(e) {}
    }
  });

  // Provide safe fallback for addTransactionEntry if some files overwrite it
  if(!window.addTransactionEntry || typeof window.addTransactionEntry !== "function"){
    window.addTransactionEntry = function(tx){
      try{
        // mirror the minimal structure used elsewhere
        const data = {
          symbol: tx?.symbol || tx?.market || tx?.symbolName || (typeof tx === "string" ? tx : "UNKNOWN"),
          stake: tx?.stake ?? tx?.amount ?? null,
          payout: tx?.payout ?? tx?.profit ?? null,
          status: tx?.status ?? (typeof tx?.payout === "number" ? (tx.payout > 0 ? "WON" : "LOST") : "CLOSED"),
          note: tx?.note || tx?.log || ""
        };
        window.dispatchEvent(new CustomEvent("kut:transaction", { detail: data }));
      }catch(e){ console.warn("fallback addTransactionEntry failed", e); }
    };
  }

})();
</script>
<!-- END: KUTMILZ TRANSACTION POPUP FIX -->

</body>
</html>
